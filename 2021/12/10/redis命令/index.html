<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>redis命令 | Star</title><meta name="author" content="Star"><meta name="copyright" content="Star"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Redis命令参考 Redis命令大全（超详细）Redis 常用操作命令，非常详细！ - 知乎 (zhihu.com) redis 命令手册 Commands | Redis 文章目录  一：序 二：Redis基本命令及常识 三：Key值命令 四：String（字符串）类型命令 五：Hash（哈希表）类型命令 六：List（集合）类型命令 七：Set（无序集合）类型命令 八：SortedSet（有">
<meta property="og:type" content="article">
<meta property="og:title" content="redis命令">
<meta property="og:url" content="https://github.com/2021/12/10/redis%E5%91%BD%E4%BB%A4/index.html">
<meta property="og:site_name" content="Star">
<meta property="og:description" content="Redis命令参考 Redis命令大全（超详细）Redis 常用操作命令，非常详细！ - 知乎 (zhihu.com) redis 命令手册 Commands | Redis 文章目录  一：序 二：Redis基本命令及常识 三：Key值命令 四：String（字符串）类型命令 五：Hash（哈希表）类型命令 六：List（集合）类型命令 七：Set（无序集合）类型命令 八：SortedSet（有">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://pic.imgdb.cn/item/657bab7ec458853aef5b7772.jpg">
<meta property="article:published_time" content="2021-12-10T12:18:30.000Z">
<meta property="article:modified_time" content="2024-04-15T06:49:38.709Z">
<meta property="article:author" content="Star">
<meta property="article:tag" content="redis">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pic.imgdb.cn/item/657bab7ec458853aef5b7772.jpg"><link rel="shortcut icon" href="https://pic.imgdb.cn/item/65697001c458853aef2aff5a.png"><link rel="canonical" href="https://github.com/2021/12/10/redis%E5%91%BD%E4%BB%A4/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'redis命令',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-04-15 14:49:38'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/background/custom.css" media="defer" onload="this.media='all'"><meta name="generator" content="Hexo 7.0.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load',() => { preloader.endLoading() })

  if (true) {
    document.addEventListener('pjax:send', () => { preloader.initLoading() })
    document.addEventListener('pjax:complete', () => { preloader.endLoading() })
  }
})()</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/6569700cc458853aef2b204a.png" onerror="onerror=null;src='https://pic.imgdb.cn/item/65697120c458853aef2e8481.gif'" alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">53</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">21</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">21</div></a></div><hr class="custom-hr"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 类别</span></a></div><div class="menus_item"><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fas fa-solid fa-image"></i><span> 相册</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://pic.imgdb.cn/item/657bab7ec458853aef5b7772.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="Star"><span class="site-name">Star</span></a></span><div id="he-plugin-simple"></div><div id="none_space"></div><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 类别</span></a></div><div class="menus_item"><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fas fa-solid fa-image"></i><span> 相册</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">redis命令</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-12-10T12:18:30.000Z" title="发表于 2021-12-10 20:18:30">2021-12-10</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-04-15T06:49:38.709Z" title="更新于 2024-04-15 14:49:38">2024-04-15</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/redis/">redis</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="redis命令"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><div class="top-img" style="background-image: url('https://pic.imgdb.cn/item/657bab7ec458853aef5b7772.jpg');"></div><article class="post-content" id="article-container"><h1 id="Redis命令"><a href="#Redis命令" class="headerlink" title="Redis命令"></a><strong>Redis命令</strong></h1><p>参考</p>
<h1 id="Redis命令大全（超详细）"><a href="#Redis命令大全（超详细）" class="headerlink" title="Redis命令大全（超详细）"></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/antLaddie/p/15362191.html">Redis命令大全（超详细）</a></h1><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/47692277">Redis 常用操作命令，非常详细！ - 知乎 (zhihu.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://redis.com.cn/commands.html">redis 命令手册</a></p>
<p><a target="_blank" rel="noopener" href="https://redis.io/commands/">Commands | Redis</a></p>
<p><strong>文章目录</strong></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/antLaddie/p/15362191.html#_label0">一：序</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/antLaddie/p/15362191.html#_label1">二：Redis基本命令及常识</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/antLaddie/p/15362191.html#_label2">三：Key值命令</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/antLaddie/p/15362191.html#_label3">四：String（字符串）类型命令</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/antLaddie/p/15362191.html#_label4">五：Hash（哈希表）类型命令</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/antLaddie/p/15362191.html#_label5">六：List（集合）类型命令</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/antLaddie/p/15362191.html#_label6">七：Set（无序集合）类型命令</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/antLaddie/p/15362191.html#_label7">八：SortedSet（有序集合）类型命令</a><ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/antLaddie/p/15362191.html#_label7_0">1：添加命令</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/antLaddie/p/15362191.html#_label7_1">2：查询命令</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/antLaddie/p/15362191.html#_label7_2">3：删除命令</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/antLaddie/p/15362191.html#_label7_3">4：其它命令</a></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/antLaddie/p/15362191.html#_label8">九：GeoSpatial（地理空间）特殊类型命令</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/antLaddie/p/15362191.html#_label9">十：HyperLogLog（超级基数统计）特殊类型命令</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/antLaddie/p/15362191.html#_label10">十一：BitMap（位图）特殊类型命令</a></li>
</ul>
<h2 id="一：序"><a href="#一：序" class="headerlink" title="一：序"></a>一：序</h2><p><strong>注意：我全文使用的Redis版本为 6.2.x 版本，低版本可能有些命令不存在；还有要想学习更全的Redis命令，<a target="_blank" rel="noopener" href="https://redis.io/commands">推荐官网学习</a></strong></p>
<p><strong>其实写本次文章让我最初模棱两可的一些命令印在我的脑海，后期在查命令也是有印象</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">本文主要介绍通俗易懂的命令，具体文章会有如下内容（红色字体，其它则会在其它文章指出）</span><br><span class="line">连接命令：连接（connection）</span><br><span class="line">基本key类型：键（key）</span><br><span class="line">基本数据类型：字符串（String）、散列（hash）、列表（list）、集合（set）、有序集合（sorted）</span><br><span class="line">特殊数据类型：位图（bitmaps）、超长日志（hyperloglog）、地理空间（geospatial）</span><br><span class="line">发布订阅命令</span><br><span class="line">事务命令...</span><br></pre></td></tr></tbody></table></figure>



<h2 id="二：Redis基本命令及常识"><a href="#二：Redis基本命令及常识" class="headerlink" title="二：Redis基本命令及常识"></a>二：Redis基本命令及常识</h2><p>在真正学习Redis之前，得先了解一下Redis的一些基本命令，这样才可以更快的知道Redis的命令用法和大概的了解</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">①：连接服务端：</span><br><span class="line">    ./redis-cli -h 127.0.0.1 -p 6379</span><br><span class="line">②：Redis默认是有16个数据库的（0~15）通过select命令来切换数据库</span><br><span class="line">    select 1    -- 连接到第 2 个数据库 0开始计算</span><br><span class="line">③：往数据库设置string类型值</span><br><span class="line">    set name zhangsan</span><br><span class="line">④：查看数据库中key的数量</span><br><span class="line">    dbsize</span><br><span class="line">⑤：查看刚才添加的key的值</span><br><span class="line">    get name</span><br><span class="line">⑥：查看所有key的值</span><br><span class="line">    keys *</span><br><span class="line">⑦：清空全部数据库和清空当前库</span><br><span class="line">    flushall（清空全部库） flushdb（清空当前库）  </span><br><span class="line">⑧：删除添加的name key键</span><br><span class="line">    del name</span><br></pre></td></tr></tbody></table></figure>



<p>三：Key值命令</p>
<p>key值命令可以说是一些类型的公共命令，比如有设置定时时间，排序，数据迁移等等</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">语法：keys pattern</span><br><span class="line">说明：用来匹配和查看指定的key</span><br><span class="line">    pattern：查询条件</span><br><span class="line">        h?llo       匹配 hello, hallo 和 hxllo</span><br><span class="line">        h*llo       匹配 hllo 和 heeeello</span><br><span class="line">        h[ae]llo    匹配 hello 和 hallo, 不匹配如 hillo</span><br><span class="line">        h[^e]llo    匹配 hallo, hbllo, ... 不匹配如 hello</span><br><span class="line">        h[a-e]llo   匹配 hallo 和 hbllo, [a-e]说明是a~e这个范围 ，如hcllo也可以匹配</span><br><span class="line">        若想匹配如转义字符的如下,就需要使用 \ 转义你想匹配的特殊字符。</span><br><span class="line">        set na\me zhangsan</span><br><span class="line">        keys na[\\]me</span><br><span class="line"></span><br><span class="line">语法：del key [key ...]</span><br><span class="line">说明：删除指定的key</span><br><span class="line">    del name age address</span><br><span class="line"></span><br><span class="line">语法：unlink key [key ...]</span><br><span class="line">说明：其实这个和删除del命令很像，也是存在key删除，不存在则忽略；删除几个键值，则返回删除的个数</span><br><span class="line">    unlink name1 name2 name3</span><br><span class="line">    注：del和unlink区别</span><br><span class="line">        del：它是线程阻塞的，当执行del命令是，del在没执行完时，其它后续的命令是无法进入的（要安全就使用del）</span><br><span class="line">        unlink:它不是线程阻塞的，当执行unlink命令时，它会将要删除的键移交给另外线程，然后将当前要删除的键与数据库空间断开连接</span><br><span class="line">                后续则由其它线程异步删除这些键（要效率快就使用unlink）</span><br><span class="line"></span><br><span class="line">语法：exists key [key ...]</span><br><span class="line">说明：返回要查询的key是否存在，存在则返回1，如果设置四个key都存在则会返回4；返回0则代表没有</span><br><span class="line">    exists name -- 查看是否存在name的key</span><br><span class="line">    exists name name  -- 重复写两次name ，如果name存在则返回2</span><br><span class="line">    exists name address -- 查看当前是否存在name和address键</span><br><span class="line">    注：exists后面不管携带单个，多个或者有重复的，最终是存在一个就累加1</span><br><span class="line"></span><br><span class="line">语法：type key</span><br><span class="line">说明：返回当前指定的key的类型。可返回的类型是: string,list,set,zset,hash和stream</span><br><span class="line"></span><br><span class="line">语法：rename key newkey</span><br><span class="line">说明：修改key名称，存在原来则覆盖，不存在则抛错；如果修改key1为key2，key2存在，则key1覆盖key2的值</span><br><span class="line">    rename name name1</span><br><span class="line">    </span><br><span class="line">语法：renamenx key newkey</span><br><span class="line">说明：修改key名称存在则覆盖，不存在则抛错；如果修改key1为key2，key2存在，则key1修改不成功</span><br><span class="line"></span><br><span class="line">语法：randomkey</span><br><span class="line">说明：随机返回一个key名称</span><br><span class="line"></span><br><span class="line">语法：copy source destination [db destination-db] [replace]</span><br><span class="line">说明：拷贝当前某一个key的值，存放到新的key中（可以跨库拷贝）返回 1 成功 0 失败</span><br><span class="line">    copy name1 name2  -- 把 name1 的值 拷贝到 name2 里</span><br><span class="line">    copy name1 name2 db 5 -- 把 name1 的值拷贝到第6号数据库name2里</span><br><span class="line">    copy name1 name2 replace -- 把 name1 的值拷贝到name2里，存在则强行覆盖</span><br><span class="line"></span><br><span class="line">语法：expire key seconds [nx|xx|gt|lt]</span><br><span class="line">    为一个存在的key设置过期时间 秒</span><br><span class="line">语法：pexpire key milliseconds [nx|xx|gt|lt]</span><br><span class="line">    为一个存在的key设置过期时间 毫秒</span><br><span class="line">语法：expireat key timestamp [nx|xx|gt|lt]</span><br><span class="line">    为一个存在的key设置过期时间 格式是uinx时间戳并精确到秒</span><br><span class="line">语法：pexpireat key milliseconds-timestamp [nx|xx|gt|lt]</span><br><span class="line">    为一个存在的key设置过期时间 格式是uinx时间戳并精确到毫秒</span><br><span class="line">说明：先设置一个key，并指定过期时间 秒/毫秒/时间戳秒/时间戳毫秒 ；返回 1 成功 0 失败</span><br><span class="line">    expire name 300 -- 把name键设置300秒过期</span><br><span class="line">    pexpire name 3000 -- 把name键设置3000毫秒过期（3秒）</span><br><span class="line">    expireat name 1633190400 -- 把name键设置为2021-10-2 00:00:00到期(精确秒)</span><br><span class="line">    pexpireat name 1633190400000 -- 把name键设置为2021-10-2 00:00:00到期(精确毫秒)</span><br><span class="line">    注:使用del可以删除定时的key</span><br><span class="line">       使用set可以覆盖定时的key；</span><br><span class="line">       使用getset可以返回并设置值，并会删除定时</span><br><span class="line">       如使用rename修改key名称，那么key定时器会被携带不会被删除</span><br><span class="line"></span><br><span class="line">语法：persist key</span><br><span class="line">说明：清除当前有定时时间的键值，设置永不过期（和普通键值一样了），关闭后并不会删除已有的键值</span><br><span class="line">    persist name    -- 关闭存在定时的键值</span><br><span class="line"></span><br><span class="line">语法：ttl key</span><br><span class="line">说明：查看当前有定时key的剩余时间，返回秒</span><br><span class="line">    </span><br><span class="line">语法：pttl key</span><br><span class="line">说明：查看当前有定时key的剩余时间，返回毫秒</span><br><span class="line">    ttl name</span><br><span class="line">    pttl name</span><br><span class="line">    注：没过期反剩余时间 过期反-2  没设置过期时间的key反-1</span><br><span class="line"></span><br><span class="line">语法：move key db</span><br><span class="line">说明：把指定的键值移动到选定的数据库db当中。如果key在目标数据库中已存在，或者key在源数据库中不存，则key不会被移动。</span><br><span class="line">    move name 2 -- 把name移动到三号数据库里</span><br><span class="line"></span><br><span class="line">语法：touch key [key ...]</span><br><span class="line">说明：修改指定key的最后访问时间。忽略不存在的 key。（我的理解是这个键被设置/更新成功，并且被放到数据库则是成功，会返回1）</span><br><span class="line">    touch name1 name2 name3     -- 返回被设置成功的键个数</span><br></pre></td></tr></tbody></table></figure>

<p><strong>①：scan cursor [match pattern] [count count] [type type]</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">说明：用于迭代当前数据库中的数据库键</span><br><span class="line">    cursor：游标（告诉迭代器从哪开始迭代）</span><br><span class="line">    [match pattern]：过滤筛选条件</span><br><span class="line">    [count count]：迭代的个数</span><br><span class="line">    [type type]：迭代的类型</span><br></pre></td></tr></tbody></table></figure>



<p><strong>②：migrate host port key|”” destination-db timeout [copy] [replace] [auth password] [auth2 username password] [keys key [key …]]</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">说明：将key原子性的从当前实例库传送到目标实例的指定数据库上，一旦迁移成功，key会在目标实例上，而当前实例上的key会被删除（默认删除）</span><br><span class="line">    host：设置迁移的IP地址</span><br><span class="line">    port：设置迁移的端口号</span><br><span class="line">    key|""：如果要迁移单个key则可以在这设置key，如果是多个key则在这里只需要设置 "" 在后面设置更多的key</span><br><span class="line">    destination-db：迁移到目标Redis服务器的哪个实例数据库</span><br><span class="line">    timeout：超时时间</span><br><span class="line">    [copy]：设置此属性代表复制迁移，不删除源实例中的key。</span><br><span class="line">    [replace]：强行替换，如果目标数据库存在则更新值，不存在则添加；如果不设置replace则代表对方数据库存在迁移的key则不成功</span><br><span class="line">    [auth password]：请求对方数据库的密码</span><br><span class="line">    [auth2 username password]：请求对方数据库的用户名和密码</span><br><span class="line">    [keys key [key ...]]：如果前面没设置 key为""，则在后面可以设置多个key迁移，如keys aaa bbb ccc</span><br></pre></td></tr></tbody></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="img"> migrate使用说明</p>
<p><strong>③：sort key [by pattern] [limit offset count] [get pattern [get pattern …]] [asc|desc] [alpha] [store destination]</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">说明：此命令是用来对list,set或sorted中元素排序；默认是按照数值排序的；并且按照两个元素的双精度浮点数类型值进行比较</span><br><span class="line">    key：排序的key</span><br><span class="line">    [by pattern]：通过引用外部key来排序</span><br><span class="line">    [limit offset count]：分页，limit 2,3 从0开始偏移到第2条数据，并查询3条数据</span><br><span class="line">    [get pattern [get pattern ...]]：获取外部key的值</span><br><span class="line">    [asc|desc]：排序的规则</span><br><span class="line">    [alpha]：当排序的集合中存在字符串则需要使用此属性，按照字典顺序排序；因为默认按照两个元素的双精度浮点数类型值进行比较</span><br><span class="line">    [store destination]：把处理好的结果存放到指定的key容器中</span><br></pre></td></tr></tbody></table></figure>



<h2 id="四：String（字符串）类型命令"><a href="#四：String（字符串）类型命令" class="headerlink" title="四：String（字符串）类型命令"></a>四：String（字符串）类型命令</h2><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">语法：set key value [ex seconds|px milliseconds|exat timestamp|pxat milliseconds-timestamp|keepttl] [nx|xx] [get]</span><br><span class="line">说明：设置string类型的键值，如果key已经保存了一个值，那么这个操作会直接覆盖原来的值，并且忽略原始类型</span><br><span class="line">    key：存储的key名称</span><br><span class="line">    value：存储的value数据</span><br><span class="line">    [ex seconds|px milliseconds|exat timestamp|pxat milliseconds-timestamp|keepttl]：</span><br><span class="line">        ex seconds：设置键key的过期时间，单位时秒</span><br><span class="line">        px milliseconds：设置键key的过期时间，单位时毫秒</span><br><span class="line">        exat timestamp：设置键过期的指定Unix时间，以秒为单位</span><br><span class="line">        pxat milliseconds-timestamp：设置键过期的指定Unix时间，以毫秒为单位</span><br><span class="line">        keepttl：获取key的过期时间</span><br><span class="line">    [nx|xx]：</span><br><span class="line">        nx：只有键key不存在的时候才会设置key的值</span><br><span class="line">        xx：只有键key存在的时候才会设置key的值</span><br><span class="line">    [get]：返回 key 存储的值，如果 key 不存在返回空</span><br><span class="line">set name zhangsan   -- 设置一个最基本的键值</span><br><span class="line">set name zhangsan ex 60     -- 设置一个键值，并指定过期时间秒，ttl可以查看过期时间</span><br><span class="line">set name zhangsan nx        -- 设置一个键值，但是加上nx 代表只能添加不存在的key，如name，如果存在name键则添加失败</span><br><span class="line">set address anhui xx        -- 设置一个键值，但是加上xx 代表只能更新已经存在的，如果address键不存在则无法更新</span><br><span class="line"></span><br><span class="line">语法：setnx key value</span><br><span class="line">说明：设置键值，存在此键则返回0不覆盖，否则正常设置</span><br><span class="line">    setnx name zhangsan     -- 设置name为键，并赋值</span><br><span class="line"></span><br><span class="line">语法：setrange key offset value</span><br><span class="line">说明：偏移量offset&gt;=0开始， 用value参数覆盖键key储存的字符串值。不存在的键key当作空白字符串处理。</span><br><span class="line">    set name zhangsan   --创建原始键值</span><br><span class="line">    setrange name 5 ' yu xiao'</span><br><span class="line">        -- 把原有的 zhangsan 从第五位之后更改（0下标）；最终变为 "zhang yu xiao"</span><br><span class="line">    setrange name 14 out</span><br><span class="line">        -- 超出偏移则使用空格 '\x00' 代替一个空格；最终变为 "zhang yu xiao\x00out"</span><br><span class="line">    setrange address 2 anhui</span><br><span class="line">        -- 如果设置的键不存在则会新建，但是偏移量会以空格代替；最终变为 "\x00\x00anhui"</span><br><span class="line"></span><br><span class="line">语法：strlen key</span><br><span class="line">说明：获取指定key所储存的字符串值的长度。当key储存的不是字符串类型时，返回错误。</span><br><span class="line"></span><br><span class="line">语法：append key value</span><br><span class="line">说明：用于为指定的key追加值，成功后返回当前键里面的字符串全部长度（如果追加有空格需要使用 ''）</span><br><span class="line">    append name 'good good boy'     -- 追加有空格的，并且成功后返回当前key的全部长度</span><br><span class="line"></span><br><span class="line">语法：get key</span><br><span class="line">说明：如果键key不存在，那么返回特殊值nil；否则返回键key的值。</span><br><span class="line">    get name -- 获取name键的值</span><br><span class="line"></span><br><span class="line">语法：getdel key</span><br><span class="line">说明：先获取到指定的key后，再删除获取的那个key；最终返回被删除的值</span><br><span class="line"></span><br><span class="line">语法：getset key value</span><br><span class="line">说明：设置更新key值，设置前先把原有的值返回出来，并设置新的值，如果key不存在时使用getset则返回nil，并设置新值</span><br><span class="line"></span><br><span class="line">语法：getrange key start end</span><br><span class="line">说明：获取指定的范围值，start（从0开始）end（从0开始）</span><br><span class="line">    set name zhangsan</span><br><span class="line">    getrange name 2 5  -- 获取范围值，最终返回 'angs'</span><br><span class="line">    getrange name 3 -2 -- 获取范围值，最终返回 'ngsa'</span><br><span class="line">    注：若使用getrange name 0 -1 (其中-1代表从后往前数)</span><br><span class="line"></span><br><span class="line">语法：getex key [ex seconds|px milliseconds|exat timestamp|pxat milliseconds-timestamp|persist]</span><br><span class="line">说明：获取指定的key值，并且获取后可以对当前key设置超时时间或者清除超时时间</span><br><span class="line">    [ex seconds|px milliseconds|exat timestamp|pxat milliseconds-timestamp|persist]：</span><br><span class="line">         ex seconds：设置键key的过期时间，单位时秒</span><br><span class="line">         px milliseconds：设置键key的过期时间，单位时毫秒</span><br><span class="line">         exat timestamp：设置键过期的指定Unix时间，以秒为单位</span><br><span class="line">         pxat milliseconds-timestamp：设置键过期的指定Unix时间，以毫秒为单位</span><br><span class="line">         persist：清除超时时间</span><br><span class="line"></span><br><span class="line">语法：mset key value [key value ...]</span><br><span class="line">说明：和set命令差不多，但是这个是批量设置，如果设置键存在则覆盖，不存在则添加</span><br><span class="line">    mset name zhangsn age 22 address anhui  -- 批量设置name和age和address</span><br><span class="line"></span><br><span class="line">语法：mget key [key ...]</span><br><span class="line">说明：批量获取键的值，如果获取的某个不存在则返回（nil），其它正常返回</span><br><span class="line">    mget name aaa   -- 批量获取name和aaa的值（aaa键不存在则返回nil）</span><br><span class="line"></span><br><span class="line">语法：setex key seconds value</span><br><span class="line">说明：将键key的值设置为value ，并将键key的过期时间设置为seconds秒钟，如果key存在则覆盖原有值</span><br><span class="line">    setex name 60 zhangsan  -- 设置key为name，并且设置60秒过期时间</span><br><span class="line"></span><br><span class="line">语法：psetex key milliseconds value</span><br><span class="line">说明：将键key的值设置为value ，并将键key的过期时间设置为milliseconds毫秒，如果key存在则覆盖原有值</span><br><span class="line">    psetex name 70000 zhangsan  -- 设置key为name，并且设置70秒过期时间</span><br><span class="line"></span><br><span class="line">语法：msetnx key value [key value ...]</span><br><span class="line">说明：当且仅当所有给定键都不存在时，为所有给定键设置值（如果添加的其中键在当前数据库存在则都不成功）</span><br><span class="line">    msetnx是一个原子性(atomic)操作，所有给定键要么就全部都被设置，要么就全部都不设置</span><br><span class="line">    msetnx name zhangsan age 22 -- 设置name和age两个键值</span><br><span class="line"></span><br><span class="line">语法：incr key</span><br><span class="line">说明：将key中储存的数字值增一，并返回增加后的值（只能用在整型，字符串啥的会报错）</span><br><span class="line"></span><br><span class="line">语法：incrby key increment</span><br><span class="line">说明：将key中储存的数字值增加指定步长increment，并返回增加后的值（只能用在整型，字符串啥的会报错）</span><br><span class="line"></span><br><span class="line">语法：incrbyfloat key increment</span><br><span class="line">说明：将key中储存的数字值增加指定步长increment，并返回增加后的值（只能用在浮点型，字符串啥的会报错）</span><br><span class="line">    incrbyfloat salary 333.33   -- 对salary添加步长333.33</span><br><span class="line"></span><br><span class="line">语法：decr key</span><br><span class="line">语法：将key中储存的数字值减一，并返回减后的值（只能用在整型，字符串啥的会报错）</span><br><span class="line"></span><br><span class="line">语法：decrby key decrement</span><br><span class="line">说明：将key中储存的数字值减指定步长increment，并返回减后的值（只能用在整型，字符串啥的会报错）</span><br></pre></td></tr></tbody></table></figure>



<h2 id="五：Hash（哈希表）类型命令"><a href="#五：Hash（哈希表）类型命令" class="headerlink" title="五：Hash（哈希表）类型命令"></a>五：Hash（哈希表）类型命令</h2><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">语法：hset key field value [field value ...]</span><br><span class="line">说明：用于为存储在key中的哈希表的field字段赋值value</span><br><span class="line">    hset student name zhangsan age 22   -- 设置key为student但里面存储着name和age字段</span><br><span class="line"></span><br><span class="line">语法：hmset key field value [field value ...]</span><br><span class="line">说明：用于同时将多个field-value(字段-值)对设置到哈希表中。此命令会覆盖哈希表中已存在的字段</span><br><span class="line">    注：Redis4.0.0起被废弃，推荐使用hset，它也可以一次性添加多个</span><br><span class="line"></span><br><span class="line">语法：hsetnx key field value</span><br><span class="line">说明：用于为存储在key中的哈希表的field字段赋值value；如果当前field存在则添加失败（不可覆盖添加）</span><br><span class="line"></span><br><span class="line">语法：hget key field</span><br><span class="line">说明：用于返回哈希表中指定字段field的值</span><br><span class="line">    hget student name  -- 获取哈希表里的field字段</span><br><span class="line"></span><br><span class="line">语法：hmget key field [field ...]</span><br><span class="line">说明：用于返回哈希表中指定字段field的值；但是可以一次性返回多个field值</span><br><span class="line">     hmget student name age     --  获取哈希表里的field多个字段</span><br><span class="line"></span><br><span class="line">语法：hdel key field [field ...]</span><br><span class="line">说明：用于删除哈希表key中的一个或多个指定字段，不存在的字段将被忽略。如果key不存在，会被当作空哈希表处理并返回0</span><br><span class="line">     hdel student name  -- 删除哈希表中key为student里的name字段</span><br><span class="line"></span><br><span class="line">语法：hexists key field</span><br><span class="line">说明：用于查看哈希表的指定字段field是否存在，1存在，0不存在</span><br><span class="line">    hexists student name    -- 查看哈希表中key为student里的name字段是否存在</span><br><span class="line"></span><br><span class="line">语法：hgetall key</span><br><span class="line">说明：用于返回存储在key中的哈希表中所有的field和value。</span><br><span class="line"></span><br><span class="line">语法：hkeys key</span><br><span class="line">说明：返回存储在key中哈希表的所有field</span><br><span class="line"></span><br><span class="line">语法：hvals key</span><br><span class="line">说明：返回存储在key中哈希表的所有value</span><br><span class="line"></span><br><span class="line">语法：hincrby key field increment</span><br><span class="line">说明：为哈希表key中的field的值加上指定的增量，并返回增量后的值（增量正数累加，增量负数递减）</span><br><span class="line">    hincrby student age 2       -- 对年龄累加</span><br><span class="line">    hincrby student age -28     -- 对年龄递减</span><br><span class="line">    注：当前命令只可操作整数类型，而字符串，浮点类型啥的会报错</span><br><span class="line"></span><br><span class="line">语法：hincrbyfloat key field increment</span><br><span class="line">说明：为哈希表key中的field的值加上指定的增量，并返回增量后的值（增量正数累加，增量负数递减）</span><br><span class="line">    hincrby student salary 300.3       -- 对工资累加</span><br><span class="line">    hincrby student salary -432.84     -- 对工资递减</span><br><span class="line">    注：当前命令只可操作整数类型、浮点类型，而操作字符串会报错</span><br><span class="line"></span><br><span class="line">语法：hstrlen key field</span><br><span class="line">说明：返回存储在key中给定field相关联的值的字符串长度（string length）</span><br><span class="line"></span><br><span class="line">语法：hlen key</span><br><span class="line">说明：用于获取哈希表中字段(fields)的数量</span><br><span class="line"></span><br><span class="line">语法：hrandfield key [count [withvalues]]</span><br><span class="line">说明：随机返回key里的field字段</span><br><span class="line">    count：返回的field个数，如果是正数且超过key里的field总数则全部返回，</span><br><span class="line">                          如果是负数且超过key里的field总数绝对值则返回空，</span><br><span class="line">        整数则返回不重复字段，负数则可能返回重复字段</span><br><span class="line">        注：在传 1 或 -1 它是随机在key里面选择，</span><br><span class="line">        在传 2 则随机返回key里的2个field字段，这两个field不可能存在重复</span><br><span class="line">        在传-2 则随机返回key里的2个field字段，这两个field可能会存在重复</span><br><span class="line">    withvalues：返回field字段时后面还返回当前field的值</span><br><span class="line"></span><br><span class="line">    hset student name zhangsan age 22 address anhui salary 3000.30  -- 初始化</span><br><span class="line">    127.0.0.1:6379&gt; hrandfield student -2</span><br><span class="line">    1) "salary"</span><br><span class="line">    2) "salary"</span><br><span class="line">    127.0.0.1:6379&gt; hrandfield student 2</span><br><span class="line">    1) "name"</span><br><span class="line">    2) "age"</span><br><span class="line">    127.0.0.1:6379&gt; hrandfield student 2 withvalues</span><br><span class="line">    1) "salary"</span><br><span class="line">    2) "3000.30"</span><br><span class="line">    3) "name"</span><br><span class="line">    4) "zhangsan"</span><br><span class="line"></span><br><span class="line">语法：hscan key cursor [match pattern] [count count]</span><br><span class="line">说明：用于遍历哈希表中的键值对</span><br><span class="line">    cursor：游标（告诉迭代器从哪开始迭代）</span><br><span class="line">    [match pattern]：过滤筛选条件</span><br><span class="line">    [count count]：迭代的个数</span><br><span class="line">    hscan student 0 match * count 2</span><br><span class="line">        -- 迭代student里的field字段，下标0开始，过滤条件*全部，但是每次迭代count为2，但2不起作用（没研究）</span><br><span class="line">        -- 具体可以查看我些的scan命令，全文搜索</span><br></pre></td></tr></tbody></table></figure>



<h2 id="六：List（集合）类型命令"><a href="#六：List（集合）类型命令" class="headerlink" title="六：List（集合）类型命令"></a>六：List（集合）类型命令</h2><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">语法：lpush key element [element ...]</span><br><span class="line">说明：将一个或多个值插入到集合key的头部（头插法），如果当前key不存在则创建新的</span><br><span class="line">     lpush listNumber 8.4 13 14 10.5 4 19.6 10 14 5.2 10 3 2.5 7 4.7 10 11.2 8 2.2 15.7 20.9</span><br><span class="line">     lpush listString  remini Momen Pledg Memo Tende Biode Revie silen Romanti AusL Simpl 　　　　　　Promis Romanti Bautifu smil Initiall sunse lemo firs Chaffere</span><br><span class="line">        -- 插入两个案例，后面以这个说明</span><br><span class="line"></span><br><span class="line">语法：lpushx key element [element ...]</span><br><span class="line">说明：往集合左边插入一个元素；若集合key不存在无法插入</span><br><span class="line"></span><br><span class="line">语法：rpush key element [element ...]</span><br><span class="line">说明：将一个或多个值插入到集合key的尾部（尾插法），如果当前key不存在则创建新的</span><br><span class="line"></span><br><span class="line">语法：rpushx key element [element ...]</span><br><span class="line">说明：往集合右边插入一个元素；若集合key不存在无法插入</span><br><span class="line"></span><br><span class="line">语法：lpop key [count]</span><br><span class="line">说明：从集合左边（头部）弹出（删除）指定的count个元素删除</span><br><span class="line">    lpop listString 2   -- 从集合左边弹出两个元素删除</span><br><span class="line"></span><br><span class="line">语法：rpop key [count]</span><br><span class="line">说明：从集合右边（尾部部）弹出（删除）指定的count个元素删除</span><br><span class="line"></span><br><span class="line">语法：blpop key [key ...] timeout</span><br><span class="line">说明：移出并获取集合头部第一个元素，如果集合没有元素会阻塞集合直到等待超时或发现可弹出元素为止，它是lpop的阻塞版</span><br><span class="line">    key：如果当前key不存在或者key内部没元素，则一直阻塞等待，等待其它客户端创建此key和元素，会立马弹出</span><br><span class="line">        但是超出延迟时间的话还没有弹出元素则会在最后弹出(nil)</span><br><span class="line">    [key ...]：设置多个key时，如果第一个key不存在则会考虑弹出第二个key,第三个key....，如果每个key都不存在或没元素</span><br><span class="line">        则当前客户端会进入一个阻塞状态，直到有元素弹出，或者自动超时弹出(nil)</span><br><span class="line">    127.0.0.1:6379&gt; blpop listA mylist 480</span><br><span class="line">    1) "mylist"</span><br><span class="line">    2) "remini"</span><br><span class="line">        -- 设置两个key，其中listString为空，会自动去找mylist集合，发现存在元素，并立刻弹出</span><br><span class="line"></span><br><span class="line">语法：brpop key [key ...] timeout</span><br><span class="line">说明：移出并获取集合尾部第一个元素，如果集合没有元素会阻塞集合直到等待超时或发现可弹出元素为止，它是lpop的阻塞版</span><br><span class="line"></span><br><span class="line">语法：llen key</span><br><span class="line">说明：获取到集合里元素的总个数</span><br><span class="line"></span><br><span class="line">语法：lrange key start stop</span><br><span class="line">说明：查询集合元素，并设置查询区间</span><br><span class="line">    start：起始值，设置正数则从左往右，设置负数则从右往左开始</span><br><span class="line">    stop：终点值，设置正数则从左往右，设置负数则从右往左开始</span><br><span class="line">    注：start（0） stop（-1）代表查询全部</span><br><span class="line">    lrange listString -5 -3</span><br><span class="line">        -- 起点从尾部往前数5个，终点从尾部往前数3个；最终显示 -5，-4，-3这三个元素</span><br><span class="line">    lrange listString -5 -8</span><br><span class="line">        -- 起点从尾部往前数5个，终点从尾部往前数8个；最终显示(empty array)</span><br><span class="line"></span><br><span class="line">语法：lindex key index</span><br><span class="line">说明：返回集合key里索引index位置存储的元素，0~n从左往右索引、-1~-n从右往左索引</span><br><span class="line">    lindex listString -1    --  获取集合listString里的最后一个索引的元素</span><br><span class="line"></span><br><span class="line">语法：lrem key count element</span><br><span class="line">说明：从集合key中删除前count个值等于element的元素</span><br><span class="line">    count &gt; 0: 从头到尾删除值为 value 的元素</span><br><span class="line">    count &lt; 0: 从尾到头删除值为 value 的元素</span><br><span class="line">    count = 0: 移除所有值为 value 的元素</span><br><span class="line">    lrem listString -2 Romanti</span><br><span class="line">        -- 移除集合listString中的Romanti元素，删除个数-2（代表从尾部查找并删除两个），并返回删除成功个数</span><br><span class="line"></span><br><span class="line">语法：lset key index element</span><br><span class="line">说明：设置集合key中index位置的元素值为新的element，index为正数则从头到位索引，为负数从尾到头索引查询</span><br><span class="line">     lset listString 2 yyds  -- 修改集合listString中索引为2的元素为yyds</span><br><span class="line"></span><br><span class="line">语法：linsert key before|after pivot element</span><br><span class="line">说明：把element元素插入到指定集合key里，但是还要以pivot内部的一个元素为基准，看是插到这个元素的左边还是右边</span><br><span class="line">    before|after：插入元素的前后位置选项</span><br><span class="line">    pivot：集合里的参考元素</span><br><span class="line">    element：待插入的元素</span><br><span class="line">    注：当集合key不存在时，这个list会被看作是空list，什么都不执行</span><br><span class="line">    注：当集合key存在，值不是列表类型时，返回错误</span><br><span class="line">    注：当给定的参考元素pivot不存在是则返回-1，因为程序不知道往哪插入</span><br><span class="line">    linsert listString after Romanti niubi -- 把niubi插入到listString集合里，插入参考Romanti元素的后面</span><br><span class="line"></span><br><span class="line">语法：lpos key element [rank rank] [count num-matches] [maxlen len]</span><br><span class="line">说明：返回集合key中匹配给定element成员的索引</span><br><span class="line">    key：要查询的集合key</span><br><span class="line">    element：要查询索引的元素</span><br><span class="line">    [rank rank]：选择匹配上的第几个元素，若超出集合指定元素的个数则返回(nil)</span><br><span class="line">    [count num-matches]：返回匹配上元素的索引个数，默认返回1个</span><br><span class="line">    [maxlen len]：告知lpos命令查询集合的前len个元素，限制查询个数</span><br><span class="line">    lpos listString Romanti     -- 查询集合listString里的Romanti出现的索引位置（0开始索引）</span><br><span class="line">    lpos listString Romanti rank 2  -- 查询Romanti元素的第二个索引位置</span><br><span class="line">    lpos listString Romanti rank 1 count 3  -- 查询Romanti索引的三条记录</span><br><span class="line">    lpos listString Romanti rank 1 count 3 maxlen 20    -- 限制查询下标为0~20</span><br><span class="line">    1) (integer) 7</span><br><span class="line">    2) (integer) 11</span><br><span class="line"></span><br><span class="line">语法：lmove source destination left|right left|right</span><br><span class="line">说明：用于原子地从source集合左边或者右边弹出一个元素，添加到destination新集合里的左边或右边</span><br><span class="line">    source：源集合</span><br><span class="line">    destination：目标集合</span><br><span class="line">    left|right left|right：</span><br><span class="line">        第一个：代表从源集合的左边或者右边弹出元素</span><br><span class="line">        第二个：代表从目标集合的左边或者右边添加</span><br><span class="line">    lmove listString mylist left right</span><br><span class="line">        -- 从listString源集合的左边弹出个元素，添加到mylist目标集合的右边</span><br><span class="line"></span><br><span class="line">语法：rpoplpush source destination</span><br><span class="line">说明：原子地从集合source中移除并返回最后一个元素，然后把这个元素插入集合destination的第一个元素</span><br><span class="line">    source：源集合</span><br><span class="line">    destination：目标集合</span><br><span class="line">    注：此方法在Redis6.2.0被废除（使用lmove代替）</span><br><span class="line"></span><br><span class="line">语法：blmove source destination left|right left|right timeout</span><br><span class="line">说明：用于原子地从source集合左边或者右边弹出一个元素，添加到destination新集合里的左边或右边，但是它时lmove的阻塞版本</span><br><span class="line">    blmove listString mylist left right 60  -- 从集合listString左边弹出一个元素放到目标集合mylist的尾部</span><br><span class="line">         但是存在60秒的超时时间，超过60秒没有弹出元素则自动失败，返回(nil)</span><br><span class="line"></span><br><span class="line">语法：brpoplpush source destination timeout</span><br><span class="line">说明：原子地从集合source中移除并返回最后一个元素，然后把这个元素插入集合destination的第一个元素（已废弃使用blmove代替）</span><br><span class="line">    brpoplpush listString mylist 50 -- 从集合listString尾部弹出一个元素添加到目标mylist集合的头部，超时时间50秒</span><br><span class="line"></span><br><span class="line">语法：ltrim key start stop</span><br><span class="line">说明：修订一个已经存在的集合；修订一个指定范围的元素放到当前集合中</span><br><span class="line">    127.0.0.1:6379&gt; ltrim listString -10 -5</span><br><span class="line">    OK</span><br><span class="line">    127.0.0.1:6379&gt; lrange listString 0 -1</span><br><span class="line">    1) "Simpl"</span><br><span class="line">    2) "AusL"</span><br><span class="line">    3) "silen"</span><br><span class="line">    4) "Revie"</span><br><span class="line">    5) "Biode"</span><br><span class="line">    6) "Tende"</span><br><span class="line"></span><br><span class="line">补充Redis7.0.0即将提供</span><br><span class="line">语法：lmpop numkeys [key [key ...]] left|right [count count]</span><br><span class="line">语法：blmpop timeout numkeys [key [key ...]] left|right [count count]</span><br></pre></td></tr></tbody></table></figure>



<h2 id="七：Set（无序集合）类型命令"><a href="#七：Set（无序集合）类型命令" class="headerlink" title="七：Set（无序集合）类型命令"></a>七：Set（无序集合）类型命令</h2><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">语法：sadd key member [member ...]</span><br><span class="line">说明：将一个或多个元素加入到集合中，添加已存在的集合元素将被忽略（不会添加上），返回添加成功的元素个数</span><br><span class="line">    127.0.0.1:6379&gt; sadd mysetA zhangsan lisi wangwu mazi zhangsan</span><br><span class="line">    (integer) 4</span><br><span class="line">        -- 成功添加四个元素，其中一个为重复的，无法添加</span><br><span class="line"></span><br><span class="line">语法：srem key member [member ...]</span><br><span class="line">说明：删除指定的元素；如果指定的元素不是集合成员则被忽略，返回被删除元素个数，不含不存在的元素</span><br><span class="line"></span><br><span class="line">语法：spop key [count]</span><br><span class="line">说明：从集合key中删除一个或多个随机元素，并返回删除的元素</span><br><span class="line"></span><br><span class="line">语法：srandmember key [count]</span><br><span class="line">说明：随机返回集合key中的一个或多个随机元素，若返回个数的count大于集合总数则返回全部</span><br><span class="line">    注：srandmember随机返回不删除原集合，spop返回并删除原集合返回的元素</span><br><span class="line"></span><br><span class="line">语法：sdiff key [key ...]</span><br><span class="line">说明：返回第一个集合与其它集合之间的差异；说白就是第一个集合的某个元素在其它集合都不存在则这个元素会被返回，</span><br><span class="line">    key1 = {a,b,c,d}</span><br><span class="line">    key2 = {c}</span><br><span class="line">    key3 = {a,c,e}</span><br><span class="line">    SDIFF key1 key2 key3  = {b,d}</span><br><span class="line">    注：如果只携带一个key比较则会返回当前集合全部元素</span><br><span class="line">    举例：</span><br><span class="line">        127.0.0.1:6379&gt; sadd mysetA zhangsan lisi wangwu mazi zhangsan</span><br><span class="line">        (integer) 4</span><br><span class="line">        127.0.0.1:6379&gt; sadd mysetB anhui shanghai zhangsan mazi</span><br><span class="line">        (integer) 4</span><br><span class="line">        127.0.0.1:6379&gt; sdiff mysetA mysetB</span><br><span class="line">        1) "wangwu"</span><br><span class="line">        2) "lisi"</span><br><span class="line"></span><br><span class="line">语法：sdiffstore destination key [key ...]</span><br><span class="line">说明：此命令和sdiff功能差不多，不同的是它将结果保存到destination集合，并返回成功添加到新集合上的个数。</span><br><span class="line">    127.0.0.1:6379&gt; sdiffstore newmyset mysetA mysetB</span><br><span class="line">    (integer) 2</span><br><span class="line"></span><br><span class="line">语法：sinter key [key ...]</span><br><span class="line">说明：返回第一个集合与其它集合之间的交集；说白就是第一个集合的某个元素在其它集合都存在则这个元素会被返回，</span><br><span class="line">    key1 = {a,b,c,d}</span><br><span class="line">    key2 = {c}</span><br><span class="line">    key3 = {a,c,e}</span><br><span class="line">    SINTER key1 key2 key3 = {c}</span><br><span class="line">    注：如果只携带一个key比较则会返回当前集合全部元素</span><br><span class="line">    举例：</span><br><span class="line">        127.0.0.1:6379&gt; sadd mysetA zhangsan lisi wangwu mazi zhangsan</span><br><span class="line">        (integer) 4</span><br><span class="line">        127.0.0.1:6379&gt; sadd mysetB anhui shanghai zhangsan mazi</span><br><span class="line">        (integer) 4</span><br><span class="line">        127.0.0.1:6379&gt; sinter mysetA mysetB</span><br><span class="line">        1) "zhangsan"</span><br><span class="line">        2) "mazi"</span><br><span class="line"></span><br><span class="line">语法：sinterstore destination key [key ...]</span><br><span class="line">说明：此命令和sinter功能差不多，不同的是它将结果保存到destination集合，并返回成功添加到新集合上的个数。</span><br><span class="line">    127.0.0.1:6379&gt; sinterstore newmyset mysetA mysetB</span><br><span class="line">    (integer) 2</span><br><span class="line"></span><br><span class="line">语法：sunion key [key ...]</span><br><span class="line">说明：用于返回所有给定集合的并集</span><br><span class="line">    key1 = {a,b,c,d}</span><br><span class="line">    key2 = {c}</span><br><span class="line">    key3 = {a,c,e}</span><br><span class="line">    sunion key1 key2 key3 = {a,b,c,d,e}</span><br><span class="line">    注：如果只携带一个key比较则会返回当前集合全部元素</span><br><span class="line">    举例：</span><br><span class="line">        127.0.0.1:6379&gt; sadd mysetA zhangsan lisi wangwu mazi zhangsan</span><br><span class="line">        (integer) 4</span><br><span class="line">        127.0.0.1:6379&gt; sadd mysetB anhui shanghai zhangsan mazi</span><br><span class="line">        (integer) 4</span><br><span class="line">        127.0.0.1:6379&gt; sunion mysetA mysetB</span><br><span class="line">        1) "mazi"</span><br><span class="line">        2) "zhangsan"</span><br><span class="line">        3) "lisi"</span><br><span class="line">        4) "anhui"</span><br><span class="line">        5) "wangwu"</span><br><span class="line">        6) "shanghai"</span><br><span class="line"></span><br><span class="line">语法：sunionstore destination key [key ...]</span><br><span class="line">说明：类似于sunion，不同的是不返回结果集，而是把返回存储在destination集合中。</span><br><span class="line">    127.0.0.1:6379&gt; sunionstore newset mysetA mysetB</span><br><span class="line">    (integer) 6</span><br><span class="line"></span><br><span class="line">语法：scard key</span><br><span class="line">说明：返回集合中元素的数量（整型值）</span><br><span class="line"></span><br><span class="line">语法：smembers key</span><br><span class="line">说明：返回存储在key中的集合的所有的成员，此命令可以使用携带单个key的sdiff、sinter、sunion命令替代</span><br><span class="line"></span><br><span class="line">语法：sismember key member</span><br><span class="line">说明：判断元素member是否是集合key的成员，是返回1，否则0</span><br><span class="line">    127.0.0.1:6379&gt; sismember mysetA zhangsan</span><br><span class="line">    (integer) 1</span><br><span class="line"></span><br><span class="line">语法：smismember key member [member ...]</span><br><span class="line">说明：批量判断元素members是否是集合key的成员，是返回1，否则0</span><br><span class="line">    127.0.0.1:6379&gt; smismember mysetA zhangsan lisi</span><br><span class="line">    1) (integer) 1</span><br><span class="line">    2) (integer) 1</span><br><span class="line"></span><br><span class="line">语法：smove source destination member</span><br><span class="line">说明：从集合source中移动成员member到集合destination；</span><br><span class="line">    注：返回1代表成功，返回0代表移动element元素在source不存在</span><br><span class="line">    注：移动成功后会把element元素在原集合上删除</span><br><span class="line">    注：若被移动的元素在两个集合都存在，则会覆盖移动，再删除原集合上的元素</span><br><span class="line">    smove mysetA mysetB  zhangsan   -- 把元素zhangsan从集合mysetA移动到mysetB上</span><br><span class="line"></span><br><span class="line">语法：sscan key cursor [match pattern] [count count]</span><br><span class="line">说明：用于遍历集合中键的元素，sscan继承自scan，具体可以参考scan，上面第三章有说明</span><br><span class="line">    key：迭代指定元素</span><br><span class="line">    cursor：游标（告诉迭代器从哪开始迭代）</span><br><span class="line">    [match pattern]：过滤筛选条件</span><br><span class="line">    [count count]：迭代的个数</span><br><span class="line">    举例：每次迭代两个</span><br><span class="line">        127.0.0.1:6379&gt; sscan mysetA 0 match * count 2</span><br><span class="line">        1) "1"</span><br><span class="line">        2) 1) "zhangsan"</span><br><span class="line">           2) "lisi"</span><br><span class="line">        127.0.0.1:6379&gt; sscan mysetA 1 match * count 2</span><br><span class="line">        1) "0"</span><br><span class="line">        2) 1) "wangwu"</span><br><span class="line">           2) "mazi"</span><br><span class="line"></span><br><span class="line">补充Redis7.0.0即将提供</span><br><span class="line">语法：sintercard key [key ...]</span><br></pre></td></tr></tbody></table></figure>





<h2 id="八：SortedSet（有序集合）类型命令"><a href="#八：SortedSet（有序集合）类型命令" class="headerlink" title="八：SortedSet（有序集合）类型命令"></a>八：SortedSet（有序集合）类型命令</h2><p>对于这个有序集合而言，比其它类型复杂一些，我以添加命令、查询命令、删除命令、其它命令等来介绍</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">下面几节案例的测试数据</span><br><span class="line">zadd myzsetA -5 &amp;&amp; -2 ## 0 @@ 1 aa 5 bb 10 cc 15 dd 20 ee 25 ff 30 gg 35 hh 40 ii 45 jj 50 kk</span><br><span class="line">zadd chinas -10 Anhui 45 Shanghai 24 Beijing 33 Henan 87 Guangdong</span><br><span class="line">zadd zsetA 20 zhangsan 25 lisi 33 wanger 15 mazi 33 babao 23 xiechao</span><br><span class="line">zadd zsetB 5 zhangsan 10 lisi 15 mazi 20 babao</span><br><span class="line">zadd zsetC 10 aa 10 bb 10 cc 10 dd 10 ee 10 ff 10 gg 10 hh</span><br></pre></td></tr></tbody></table></figure>



<h3 id="1：添加命令"><a href="#1：添加命令" class="headerlink" title="1：添加命令"></a>1：添加命令</h3><p><strong>①：zadd key [nx|xx] [gt|lt] [ch] [incr] score member [score member …]</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">语法：zadd key [nx|xx] [gt|lt] [ch] [incr] score member [score member ...]</span><br><span class="line">说明：用于将一个或多个member元素及其score值加入到有序集key当中，若添加的member已存在则更新当前分数</span><br><span class="line">    [nx|xx]:</span><br><span class="line">        nx：只能做添加操作</span><br><span class="line">        xx：只能做更新操作</span><br><span class="line">    [gt|lt]:</span><br><span class="line">        gt：更新的元素分数必须比原分数大</span><br><span class="line">        lt：更新的元素分数必须比原分数小</span><br><span class="line">    [ch]：返回添加和更新成功的个数</span><br><span class="line">    [incr]：累加操作，score代表更新member的步长</span><br><span class="line">    注：gt,lt 和 nx 三者互斥不能同时使用</span><br><span class="line">    注：分数的取值范围-9007199254740992到9007199254740992</span><br></pre></td></tr></tbody></table></figure>



<h3 id="2：查询命令"><a href="#2：查询命令" class="headerlink" title="2：查询命令"></a>2：查询命令</h3><p><strong>①：zrange key min max [byscore|bylex] [rev] [limit offset count] [withscores]</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">语法：zrange key min max [byscore|bylex] [rev] [limit offset count] [withscores]</span><br><span class="line">说明：返回有序集中，指定区间内的成员，其中成员查询可以按照下标，分数，元素来获取指定范围</span><br><span class="line">    key：要查询的有序集合</span><br><span class="line">    min：查询范围的最小值，按照不同的方式写不同的最小值</span><br><span class="line">        下标查询写下标值（默认）,分数查询写分数值（设置byscore），元素查询写元素值（设置bylex）</span><br><span class="line">    max：查询范围的最大值，按照不同的方式写不同的最大值</span><br><span class="line">        下标查询写下标值（默认）,分数查询写分数值（设置byscore），元素查询写元素值（设置bylex）</span><br><span class="line">    [byscore|bylex]：</span><br><span class="line">        byscore：按照分数排序，此时查询时只会按照分数的范围查询，切记不能写字符啥的</span><br><span class="line">            -inf +inf byscore 代表查询分数在负无穷 ~ 正无穷</span><br><span class="line">            -20 20    byscore 代表查询分数在 -20 ~ 20之间的元素(包含-20和20)</span><br><span class="line">            10 (20    byscore 代表查询分数在 10 ~ 20之间的元素(包含10，不包含20)</span><br><span class="line">        bylex：按照元素属性ASCLL来排序，此时查询时只会按照元素范围查询</span><br><span class="line">            - + bylex       代表查询元素范围为全部</span><br><span class="line">            - [cc bylex     代表从开头查询到元素 cc 位置（包含cc）</span><br><span class="line">            [aa [dd bylex   代表查询元素为aa ~ dd之间的范围（包含aa和dd）</span><br><span class="line">            (cc [ff bylex   代表查询元素为cc ~ ff之间的范围（包含ff，不包含cc）</span><br><span class="line">            (aa (ee bylex   代表查询元素为aa ~ ee之间的范围（不包含aa和ee）</span><br><span class="line">    [rev]：设置倒序排列，这时候我们就得注意写最大值和最小值要反过来写</span><br><span class="line">    [limit offset count]：筛选后的结果排序</span><br><span class="line">        offset：起始位（0下标开始数）</span><br><span class="line">        count：查询元素个数</span><br><span class="line">    [withscores]：最终查询结果显示分数，但是只适用于byscore查询和默认下标查询</span><br><span class="line">    注：下标查询时是默认的，不用写[byscore|bylex]，下面写-1，代表右边第一个，所有0 -1代表查询全部</span><br><span class="line">    注：若某个有序集合使用元素查询时（bylex），那么我推荐你最好使用分数都是相同的有序集合！</span><br><span class="line">        因为分数会打乱原有我们添加的顺序，下面举个普通例子：</span><br><span class="line">          执行命令=&gt;：zadd newKey 6 aa 3 bb 4 cc</span><br><span class="line">          有序集合存储元素变为=&gt;：3 bb 4 cc 6 aa</span><br><span class="line">          它会按照分数排序了，这样按照元素获取范围就不准了，如获取[aa [bb bylex</span><br><span class="line">          127.0.0.1:6379&gt; zrange newKey 0 -1</span><br><span class="line">          1) "bb"</span><br><span class="line">          2) "cc"</span><br><span class="line">          3) "aa"</span><br><span class="line">          127.0.0.1:6379&gt; zrange newKey [aa [cc bylex</span><br><span class="line">          1) "bb"</span><br><span class="line">          2) "cc"</span><br><span class="line">          3) "aa"</span><br><span class="line">          127.0.0.1:6379&gt; zrange newKey [aa [bb bylex</span><br><span class="line">          1) "bb"</span><br><span class="line">          此时会发现有点不对劲，[aa [bb bylex 为什么没有aa呢？因为分数打乱了顺序</span><br><span class="line">          其实用到元素查询那么有序集合里面的每个元素分数都是相同的，添加相同分数，元素会强行按照字典ASCII进行排序</span><br><span class="line">          执行命令=&gt;：zadd newKey1 0 bb 0 aa 0 cc</span><br><span class="line">          执行时插入时遇到分数相同的则会对元素的ASCII排序</span><br><span class="line">          127.0.0.1:6379&gt; zrange newKey1 0 -1</span><br><span class="line">          1) "aa"</span><br><span class="line">          2) "bb"</span><br><span class="line">          3) "cc"</span><br><span class="line">          127.0.0.1:6379&gt; zrange newKey1 [aa [bb bylex</span><br><span class="line">          1) "aa"</span><br><span class="line">          2) "bb"</span><br><span class="line">          127.0.0.1:6379&gt;</span><br><span class="line">        再说了，使用bylex元素查询我们也不能指定withscores</span><br><span class="line">    zrange演变命令</span><br><span class="line">        zrangebyscore、zrangebylex、zrangestore</span><br><span class="line">        zrevrange、zrevrangebyscore、zrevrangebylex</span><br></pre></td></tr></tbody></table></figure>



<p><strong>②：zinter numkeys key [key …] [weights weight [weight …]] [aggregate sum|min|max] [withscores]</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">语法：zinter numkeys key [key ...] [weights weight [weight ...]] [aggregate sum|min|max] [withscores]</span><br><span class="line">说明：计算numkeys个有序集合的交集（就是把几个相同元素的分数进行处理）</span><br><span class="line">    numkeys：计算交集的key个数</span><br><span class="line">    key | [key ...]：设置要处理交集的有序集合，按照我们给出的numkeys写指定个数的key</span><br><span class="line">    [weights weight [weight ...]]：权重计算（乘法因子）；要设置权重的话，则有几个key就得写几个权重值</span><br><span class="line">        若key1 key2 weights 10 15 说明：第一个key里面的全部分数要乘于10，第二个key的全部分数乘于15</span><br><span class="line">        注：此属性在交集、并集计算中都存在，只要是符合[交集|并集]的才会计算并返回给客户端</span><br><span class="line">    [aggregate sum|min|max]：你可以指定交集、并集的结果集的聚合方式</span><br><span class="line">        注：指定sum（默认）则交集的元素的分数结合，若指定max，则会选择最大的作为交集的分数</span><br><span class="line">    [withscores]：显示分数</span><br></pre></td></tr></tbody></table></figure>



<p><strong>③：zunion numkeys key [key …] [weights weight [weight …]] [aggregate sum|min|max] [withscores]</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">语法：zunion numkeys key [key ...] [weights weight [weight ...]] [aggregate sum|min|max] [withscores]</span><br><span class="line">说明：计算给定的numkeys个有序集合的并集，并且返回结果</span><br><span class="line">     numkeys：计算交集的key个数</span><br><span class="line">     key | [key ...]：设置要处理交集的有序集合，按照我们给出的numkeys写指定个数的key</span><br><span class="line">     [weights weight [weight ...]]：权重计算（乘法因子）；要设置权重的话，则有几个key就得写几个权重值</span><br><span class="line">         若key1 key2 weights 10 15 说明：第一个key里面的全部分数要乘于10，第二个key的全部分数乘于15</span><br><span class="line">         注：此属性在交集、并集计算中都存在，只要是符合[交集|并集]的才会计算并返回给客户端</span><br><span class="line">     [aggregate sum|min|max]：你可以指定交集、并集的结果集的聚合方式</span><br><span class="line">         注：指定sum（默认）则交集的元素的分数结合，若指定max，则会选择最大的作为交集的分数</span><br><span class="line">     [withscores]：显示分数</span><br><span class="line">     注：并集就是把几个集合的元素并到一起（不漏任何元素），然后单个元素单独计算，多个元素计算后合并到一起</span><br></pre></td></tr></tbody></table></figure>



<p><strong>④：查询基本命令</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">语法：zinterstore destination numkeys key [key ...] [weights weight [weight ...]] [aggregate sum|min|max]</span><br><span class="line">说明：计算numkeys个有序集合的交集，并且把结果放到destination中；具体操作看zinter，</span><br><span class="line">    destination：新集合名称，用来存放处理好交集的数据</span><br><span class="line"></span><br><span class="line">语法：zintercard numkeys key [key ...]</span><br><span class="line">说明：Redis7.0发布</span><br><span class="line"></span><br><span class="line">语法：zunionstore destination numkeys key [key ...] [weights weight [weight ...]] [aggregate sum|min|max]</span><br><span class="line">说明：计算给定的numkeys个有序集合的并集，并且把结果放到destination中。（具体参考zunion）</span><br><span class="line">    destination：计算后的结果返回到指定的有序集合里</span><br><span class="line"></span><br><span class="line">语法：zrangebyscore key min max [withscores] [limit offset count]</span><br><span class="line">说明：（演变）返回有序集中，按照分数来指定区间内的成员，具体参考zrange</span><br><span class="line">    zrangebyscore myzsetA -inf +inf withscores  -- 查询分数在负无穷~正无穷</span><br><span class="line"></span><br><span class="line">语法：zrangebylex key min max [limit offset count]</span><br><span class="line">说明：（演变）返回有序集中，按照元素来指定区间内的成员，具体参考zrange</span><br><span class="line">     zrangebylex myzsetA [aa [dd    -- 查询元素在aa ~ dd之间（包含aa和dd）</span><br><span class="line"></span><br><span class="line">语法：zrangestore dst src min max [byscore|bylex] [rev] [limit offset count]</span><br><span class="line">说明：（演变）指定区间内的成员，其中成员查询可以按照下标，分数，元素来获取指定范围，并存储在dst新的有序集合里</span><br><span class="line">    dst：存储查询结果的有序集合</span><br><span class="line">    src：要查询的有序集合</span><br><span class="line">    注：具体操作和参数介绍看zrange</span><br><span class="line">    zrangestore newzset myzsetA 0 -1 -- 查询的全部元素存放到指定有序集合里，返回添加成功的个数</span><br><span class="line"></span><br><span class="line">语法：zrevrange key start stop [withscores]</span><br><span class="line">说明：（演变）返回有序集key中，指定区间内的成员。其中成员的位置按score值递减(从高到低)来排列获取</span><br><span class="line">     zrevrange myzsetA 0 -1 withscores  -- 查询有序集合中myzsetA的全部元素的分数降序</span><br><span class="line"></span><br><span class="line">语法：zrevrangebyscore key max min [withscores] [limit offset count]</span><br><span class="line">说明：（演变）返回有序集合key中指定分数区间的成员列表。有序集成员按分数值递增(从小到大)次序排列获取</span><br><span class="line">     zrevrangebyscore myzsetA +inf -inf withscores -- 按照分数降序区间查询</span><br><span class="line"></span><br><span class="line">语法：zrevrangebylex key max min [limit offset count]</span><br><span class="line">说明：（演变）返回有序集合key中指定元素区间的成员列表来获取按元素字典排序递增(从小到大)次序排列获取</span><br><span class="line">     zrevrangebylex myzsetA + -     -- 按照元素降序区间查询</span><br><span class="line"></span><br><span class="line">语法：zcard key</span><br><span class="line">说明：获取有序集的成员个数</span><br><span class="line"></span><br><span class="line">语法：zrank key member</span><br><span class="line">说明：返回有序集key中成员member的排名，其中有序集成员按score值从低到高排列，（推荐分数相同时使用）</span><br><span class="line">    注：推荐在有序集合相同分数的情况下使用，具体可以本章的zrange</span><br><span class="line">    zrank myzsetA cc    -- 获取有序集合中myzsetA的cc下标位置</span><br><span class="line"></span><br><span class="line">语法：zrevrank key member</span><br><span class="line">说明：返回有序集key中成员member的排名，其中有序集成员按score值从高到低排列</span><br><span class="line">     zrevrank myzsetA jj  -- 倒序获取有序集合中的 jj 位置下标</span><br><span class="line"></span><br><span class="line">语法：zscore key member</span><br><span class="line">说明：用于返回有序集和key中成员member的分数（不存在的元素返回nil）</span><br><span class="line"></span><br><span class="line">语法：zmscore key member [member ...]</span><br><span class="line">说明：用于返回有序集和key中多个成员member的分数（不存在的元素返回nil）</span><br><span class="line">    zmscore myzsetA aa bb ccc   查看aa、bb、ccc分数（ccc不存在返回nil）</span><br><span class="line">    1) "1"</span><br><span class="line">    2) "5"</span><br><span class="line">    3) (nil)</span><br><span class="line"></span><br><span class="line">语法：zrandmember key [count [withscores]]</span><br><span class="line">说明：随机获取有序集合key内部的指定元素个数的，</span><br><span class="line">    注：当count为1 或者 -1 看不出效果</span><br><span class="line">    注：当count为 2 ~ 正无穷 ，则会返回不同的元素，不会重复，若集合5个元素，你count为10，最终也返回5个几个（不能重复）</span><br><span class="line">    注：当count为 -2 ~ 负无穷，则可能会出现返回重复的元素，若集合5个元素，你count为100，最终会随机获取100个返回</span><br><span class="line">    127.0.0.1:6379&gt; zrandmember zsetB 6 withscores      -- 把集合内部的4个元素全部返回出来了，无法返回6个（不能重复）</span><br><span class="line">    1) "babao"</span><br><span class="line">    2) "20"</span><br><span class="line">    3) "mazi"</span><br><span class="line">    4) "15"</span><br><span class="line">    5) "lisi"</span><br><span class="line">    6) "10"</span><br><span class="line">    7) "zhangsan"</span><br><span class="line">    8) "5"</span><br><span class="line">    127.0.0.1:6379&gt; zrandmember zsetB -5 withscores   -- 随机从集合内部选出5个元素</span><br><span class="line">     1) "lisi"</span><br><span class="line">     2) "10"</span><br><span class="line">     3) "mazi"</span><br><span class="line">     4) "15"</span><br><span class="line">     5) "mazi"</span><br><span class="line">     6) "15"</span><br><span class="line">     7) "lisi"</span><br><span class="line">     8) "10"</span><br><span class="line">     9) "babao"</span><br><span class="line">    10) "20"</span><br><span class="line"></span><br><span class="line">语法：zscan key cursor [match pattern] [count count]</span><br><span class="line">说明：迭代遍历集合内部元素（具体查看scan命令）</span><br><span class="line">    cursor：游标（告诉迭代器从哪开始迭代）</span><br><span class="line">    [match pattern]：过滤筛选条件</span><br><span class="line">    [count count]：迭代的个数</span><br><span class="line">    zscan  myzsetA 0 match * count 2</span><br><span class="line">        -- 遍历有序集合myzsetA，从游标0开始（最头部），查询两个</span><br></pre></td></tr></tbody></table></figure>



<h3 id="3：删除命令"><a href="#3：删除命令" class="headerlink" title="3：删除命令"></a>3：删除命令</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">语法：zrem key member [member ...]</span><br><span class="line">说明：用于从有序集合key中删除指定的多个成员member。如果member不存在则被忽略</span><br><span class="line"></span><br><span class="line">语法：zremrangebyrank key start stop</span><br><span class="line">说明：移除有序集key中，指定排名(rank)区间start和stop内的所有成员，下标参数start和stop都是从0开始计数</span><br><span class="line">    注：按照下标删除元素</span><br><span class="line">    zremrangebyrank myzsetA 0 -2 -- 删除从左边开始到右边倒数第二个的范围元素</span><br><span class="line"></span><br><span class="line">语法：zremrangebylex key min max</span><br><span class="line">说明：删除成员名称按字典由低到高排序介于min和max之间的所有成员；按照元素删除的话推荐在分数相同</span><br><span class="line">     的情况下使用，因为每次添加带有不同分数的元素会找到自己的位置插入添加，不是按照字典由低到高插入添加</span><br><span class="line">     所有我们后期删除时结果由于分数的影像导致删除不准确</span><br><span class="line">    注：按照元素删除元素</span><br><span class="line">    zremrangebylex myzsetA [aa (kk -- 删除元素在aa ~ kk 之间的（包括aa，不包括kk）</span><br><span class="line"></span><br><span class="line">语法：zremrangebyscore key min max</span><br><span class="line">说明：移除有序集key中，所有score值介于min和max之间(包括等于min或max)的成员</span><br><span class="line">    注：按照分数删除元素</span><br><span class="line">    zremrangebyscore myzsetA (-2 (30    -- 根据分数删除指定范围的元素（不包含-2和30）</span><br><span class="line"></span><br><span class="line">语法：zpopmax key [count]</span><br><span class="line">说明：删除分数最高的count个元素，如果未指定count则默认为1 ，删除会按照排序从高到低删除指定count个元素</span><br><span class="line"></span><br><span class="line">语法：zpopmin key [count]</span><br><span class="line">说明：删除分数最低的count个元素，如果未指定count则默认为1 ，删除会按照排序从低到高删除指定count个元素</span><br><span class="line"></span><br><span class="line">语法：bzpopmax key [key ...] timeout</span><br><span class="line">说明：和zpopmax一样，只不过是阻塞删除（若没有指定集合或元素则等待被创建），一次性删除一个，超时就自动退出</span><br><span class="line"></span><br><span class="line">语法：bzpopmin key [key ...] timeout</span><br><span class="line">说明：和zpopmin一样，只不过是阻塞删除（若没有指定集合或元素则等待被创建），一次性删除一个，超时就自动退出</span><br></pre></td></tr></tbody></table></figure>





<h3 id="4：其它命令"><a href="#4：其它命令" class="headerlink" title="4：其它命令"></a>4：其它命令</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">语法：zcount key min max</span><br><span class="line">说明：返回有序集key中，score值在min和max之间(min&lt;=score&gt;=max)的成员的数量</span><br><span class="line">    min：最小值，可以使用 -inf 代表负无穷大，默认是包含最小值，source&gt;=min；若不包含可在值前面添加 '(' 如 (-20</span><br><span class="line">    max：最大值，可以使用 +inf 代表正无穷大，默认是包含最大值，source&lt;=max；若不包含可在值前面添加 '(' 如 (20</span><br><span class="line">    举例：</span><br><span class="line">        zcount myzsetA -inf +inf    -- 查询有序集合里的全部成员数量</span><br><span class="line">        zcount myzsetA -20 15       -- 查询成员分数在-20 ~ 15 之间，包含-20和15</span><br><span class="line">        zcount myzsetA (-20 (20     -- 查询成员分数在-20 ~ 20 之间，不包含-20和20</span><br><span class="line"></span><br><span class="line">语法：zlexcount key min max</span><br><span class="line">说明：返回有序集合key中，元素在min和max之间的成员数量，元素是按照字典排序（ASCII）的方式存在min和max</span><br><span class="line">    注：关于对元素范围统计，推荐元素的分数都为一个固定的相同值，要不然会有一个偏差，（具体看range参数说明）</span><br><span class="line">    zlexcount zsetC  [bb [gg -- 获取有序集合zsetC里bb ~ gg范围元素个数（包含bb和gg）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">语法：zincrby key increment member</span><br><span class="line">说明：为有序集key的成员member的score值加上增量increment</span><br><span class="line">    注：若key不存在，或者member不是当前key成员，则此命令自动转换为zadd命令</span><br><span class="line">    zincrby chinas 4 Anhui  -- 在有序集合上的Anhui元素分数增量 +4</span><br><span class="line"></span><br><span class="line">语法：zdiff numkeys key [key ...] [withscores]</span><br><span class="line">说明：计算第一个有序集合与其它集合的元素差异，并返回给客户端，若指定一个有序集合key则返回全部元素</span><br><span class="line">    注：numkeys设置key的数量，必须与key个数对应</span><br><span class="line">    zdiff 2 zsetA zsetB</span><br><span class="line">    1) "xiechao"</span><br><span class="line">    2) "wanger"</span><br><span class="line">        -- 以zsetA为基准计算与其它集合的差异</span><br><span class="line"></span><br><span class="line">语法：zdiffstore destination numkeys key [key ...]</span><br><span class="line">说明：计算第一个有序集合与其它集合的元素差异，并存放到新集合中，若新集合存在则覆盖里面内容</span><br><span class="line">    注：numkeys设置key的数量，必须与key个数对应</span><br><span class="line">    zdiffstore newzset 2 zsetA zsetB</span><br><span class="line">    (integer) 2</span><br><span class="line">         -- 以zsetA为基准计算与其它集合的差异，并存放到newzset集合中</span><br></pre></td></tr></tbody></table></figure>





<h2 id="九：GeoSpatial（地理空间）特殊类型命令"><a href="#九：GeoSpatial（地理空间）特殊类型命令" class="headerlink" title="九：GeoSpatial（地理空间）特殊类型命令"></a>九：GeoSpatial（地理空间）特殊类型命令</h2><p>geospatial地理位置命令其实底层使用的是zset，我们可以通过type来验证geospatial的空间集合key，会返回zset，那么就可以说明geospatial里面添加的全部元素我基本上可以使用zset的命令处理，但是针对geospatial内的一些特有命令是无法使用zset命令来处理的，我们最多使用zset内的zrange（查询）,zrem（删除）等</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">测试数据：geoadd wan 117.30794 31.79322 hefei 118.38548 31.34072 wuhu 116.53949 31.74933 luan 115.77914 33.87641 bozhou 117.56733 30.68673 chizhou 118.75634 30.94622 xuancheng 118.30553 32.2948 chuzhou 116.97728 33.64004 suzou</span><br><span class="line">语法：geoadd key [nx|xx] [ch] longitude latitude member [longitude latitude member ...]</span><br><span class="line">说明：将指定的地理空间(经度、纬度、名称)添加到指定的键中。数据以排序集的形式存储到键中</span><br><span class="line">    [nx|xx]：</span><br><span class="line">        nx：只能进行添加操作，无法更新已经存在的坐标</span><br><span class="line">        xx：只能进行更新操作，无法添加一个不存在的坐标</span><br><span class="line">    [ch]：ch是changed缩写，添加此属性，就会在每次成功后返回添加成功的坐标和更改成功的坐标的次数汇总</span><br><span class="line">        注：geoadd的默认不添加ch的返回值只计算新增元素的数量，而更新的则不统计在内</span><br><span class="line">    longitude：经度</span><br><span class="line">    latitude：纬度</span><br><span class="line">    member：坐标名称</span><br><span class="line">    注：有效经度 -180° ~ 180°</span><br><span class="line">    注：有效纬度 -85.05112878° ~ 85.05112878°</span><br><span class="line">    举例：</span><br><span class="line">        geoadd Anhui 117.30794 31.79322 hefei 118.38548 31.34072 wuhu 116.53949 31.74933 luan</span><br><span class="line">        (integer) 3</span><br><span class="line">            -- 在安徽key里面添加合肥、芜湖、六安三地坐标</span><br><span class="line">        geoadd Anhui 115 32 hefei 119 32 wuhu 117.03424 30.51227 anqing</span><br><span class="line">        (integer) 1</span><br><span class="line">            -- 在安徽key里面更新 合肥、芜湖，并添加一个 安庆 （参考第一条命令）</span><br><span class="line">        geoadd Anhui nx 118.75634 30.94622 xuancheng</span><br><span class="line">        (integer) 1</span><br><span class="line">            -- 用nx修饰，只能添加元素，无法修改，添加 宣城坐标</span><br><span class="line">        geoadd Anhui xx 119.75634 32.94622 xuancheng</span><br><span class="line">        (integer) 0</span><br><span class="line">            -- 用xx修饰，只能修改元素，无法添加，修改 宣城坐标；；这里默认修改是不返回具体数据，只返回0</span><br><span class="line">        geoadd Anhui ch 119 33 xuancheng 118 32 anqing 116.83359  32.63142 huainan</span><br><span class="line">        (integer) 3</span><br><span class="line">            -- 用ch修饰，表示更改、添加都会被记录统计，两次修改一次添加（三次操作）</span><br><span class="line">安徽省16个市的坐标</span><br><span class="line">   经度       纬度      名称</span><br><span class="line">117.30794  31.79322   合肥市</span><br><span class="line">118.38548  31.34072   芜湖市</span><br><span class="line">117.36779  32.94448   蚌埠市</span><br><span class="line">116.83359  32.63142   淮南市</span><br><span class="line">118.84432  31.55856   马鞍山市</span><br><span class="line">116.82803  33.99141   淮北市</span><br><span class="line">117.80103  30.90466   铜陵市</span><br><span class="line">117.03424  30.51227   安庆市</span><br><span class="line">118.14161  30.27296   黄山市</span><br><span class="line">115.85668  32.91303   阜阳市</span><br><span class="line">116.97728  33.64004   宿州市</span><br><span class="line">118.30553  32.2948    滁州市</span><br><span class="line">116.53949  31.74933   六安市</span><br><span class="line">118.75634  30.94622   宣城市</span><br><span class="line">117.56733  30.68673   池州市</span><br><span class="line">115.77914  33.87641   亳州市</span><br><span class="line"></span><br><span class="line">语法：geopos key member [member ...]</span><br><span class="line">说明：从键里面返回所有给定位置元素的位置（经度和纬度）</span><br><span class="line">    注：返回的坐标可能不完全是当初添加元素的坐标，可能会有一点点误差</span><br><span class="line">    127.0.0.1:6379&gt; geopos Anhui hefei luan     -- 获取合肥和六安的地理空间经纬度</span><br><span class="line">    1) 1) "117.30793744325637817"</span><br><span class="line">       2) "31.79321915080526395"</span><br><span class="line">    2) 1) "116.53948992490768433"</span><br><span class="line">       2) "31.74933045393131437"</span><br><span class="line"></span><br><span class="line">语法：geodist key member1 member2 [m|km|ft|mi]</span><br><span class="line">说明：计算并返回两个元素地理空间之间的距离，若其中一个地理空间不存在则计算返回一个（nil）空</span><br><span class="line">    [m|km|ft|mi]：</span><br><span class="line">    m(meter)：米     km(kilometer)：千米   ft(ft)：英尺   mi(miles)：英里</span><br><span class="line">    1000m = 1km ；5280ft = 1mi ；1mi = 1609.34m</span><br><span class="line">    举例：</span><br><span class="line">        geodist Anhui hefei luan km     -- 计算千米</span><br><span class="line">        "72.8279"</span><br><span class="line">        geodist Anhui hefei luan m      -- 计算米</span><br><span class="line">        "72827.8708"</span><br><span class="line"></span><br><span class="line">语法：geohash key member [member ...]</span><br><span class="line">说明：返回一个有效的hash字符串，返回的字符串是11位的字符，它与Redis内部的52位表示精度相差可以忽略</span><br><span class="line">     若两个11位的hash字符串越接近，那么代表坐标越接近</span><br><span class="line">     127.0.0.1:6379&gt; geohash Anhui luan hefei       -- 获取六安和合肥的距离</span><br><span class="line">     1) "wtduegv3qb0"</span><br><span class="line">     2) "wtekv7v0cj0"</span><br><span class="line"></span><br><span class="line">语法：georadius key longitude latitude radius m|km|ft|mi [withcoord] [withdist] [withhash] [count count [any]] [asc|desc] [store key] [storedist key]</span><br><span class="line">说明：获取指定空间集合key里空间元素在给定的经纬度范围之内的空间元素，可以用于实现附近的人功能</span><br><span class="line">    （我们提供一个经纬度（中心点），再指定一个之前geoadd添加的空间集和，然后再设置查询范围，看看哪些地理空间元素在空间范围内（参考雷达图））</span><br><span class="line">    注：在Redis6.2.0版本中推荐使用geosearch、geosearchstore，当前方式已废弃并不推荐使用</span><br><span class="line">    key：提供一个我们添加好的空间集合</span><br><span class="line">    longitude：中心点位置经度</span><br><span class="line">    latitude：中心点位置纬度</span><br><span class="line">    radius：半径的值（搜素的范围，参考雷达图）</span><br><span class="line">    m|km|ft|mi：半径的值是以什么为单位</span><br><span class="line">    [withcoord]：返回的结果中包含经纬度</span><br><span class="line">    [withdist]：返回的结果中包含离中心点的位置距离</span><br><span class="line">    [withhash]：返回的结果中包含geohash（此值用来表示经纬度，但是用hash不是太准）</span><br><span class="line">    [count count [any]]：指定返回结果的数量</span><br><span class="line">    [asc|desc]：返回结果按照离中心节点的距离做升序或者降序</span><br><span class="line">    [store key]：（结果存储到外部集合）将返回结果的地理位置信息保存到指定空的空间集合中</span><br><span class="line">    [storedist key]：（结果存储到外部集合）将返回结果的空间元素离中心节点的距离保存到指定空的空间集合中</span><br><span class="line">    注：withcoord、withdist、withhash三个属性不能与store、storedist一起使用，因为前三个with*是用来直接返回展示的</span><br><span class="line">    举例：</span><br><span class="line">        georadius wan 114.22 30.33 440 km</span><br><span class="line">        1) "luan"</span><br><span class="line">        2) "chizhou"</span><br><span class="line">        3) "hefei"</span><br><span class="line">        4) "xuancheng"</span><br><span class="line">        5) "wuhu"</span><br><span class="line">        6) "bozhou"</span><br><span class="line">            -- 获取坐标114.22 30.33在空间集合wan（皖）里中心点440km范围的全部元素</span><br><span class="line"></span><br><span class="line">        127.0.0.1:6379&gt; georadius wan 114.22 30.33 440 km withcoord withdist withhash count 1</span><br><span class="line">        1) 1) "luan"</span><br><span class="line">           2) "271.6188"            -- 注：我们设置中心点范围什么单位，这里就什么单位</span><br><span class="line">           3) (integer) 4052658908461674    -- geohash</span><br><span class="line">           4) 1) "116.53948992490768433"    -- 经度</span><br><span class="line">              2) "31.74933045393131437"     -- 纬度</span><br><span class="line">            -- 获取中心点范围的空间元素，并在返回结果中返回当前空间元素经纬度、举例中心点举例、geohash值，并设置返回一个</span><br><span class="line"></span><br><span class="line">        127.0.0.1:6379&gt; georadius wan 114.22 30.33 440 km count 1 store map1</span><br><span class="line">        (integer) 1</span><br><span class="line">        127.0.0.1:6379&gt; zrange map1 0 -1 withscores</span><br><span class="line">        1) "luan"</span><br><span class="line">        2) "4052658908461674"</span><br><span class="line">            -- 把结果写出到外部集合中，store代表写出到外部集合，元素为空间名称，”分数store“为geohash</span><br><span class="line"></span><br><span class="line">        127.0.0.1:6379&gt; georadius wan 114.22 30.33 440 km count 1 storedist map2</span><br><span class="line">        (integer) 1</span><br><span class="line">        127.0.0.1:6379&gt; zrange map2 0 -1 withscores</span><br><span class="line">        1) "luan"</span><br><span class="line">        2) "271.61880150367676"</span><br><span class="line">            -- 把结果写出到外部集合中，storedist代表写出外部集合（并携带距离中心点距离），</span><br><span class="line">                元素为空间名称，”分数store“为距离中心点的距离</span><br><span class="line"></span><br><span class="line">语法：georadiusbymember key member radius m|km|ft|mi [withcoord] [withdist] [withhash] [count count [any]] [asc|desc] [store key] [storedist key]</span><br><span class="line">说明：和georadius命令相似，当前命令是以指定空间名称位置为中心点来往外扩展范围查询</span><br><span class="line">    member：从设置的key内部选择一个空间名称当中心点来计算范围</span><br><span class="line">    注：具体参考georadius；因为georadius以经纬度定位中心点、georadiusbymember以空间元素定位中心点</span><br><span class="line">    注：在Redis6.2.0版本中推荐使用geosearch、geosearchstore，当前方式已废弃并不推荐使用</span><br><span class="line"></span><br><span class="line">语法：geosearch key [frommember member] [fromlonlat longitude latitude] [byradius radius m|km|ft|mi] [bybox width height m|km|ft|mi] [asc|desc] [count count [any]] [withcoord] [withdist] [withhash]</span><br><span class="line">说明：计算给定的中心点（空间名称或者经纬度）的指定半径内的全部空间元素，（参考雷达图）</span><br><span class="line">    key：提供一个geoadd的空间集合key</span><br><span class="line">    [frommember member]：在我们指定的空间集合中选择一个空间元素作为中心点</span><br><span class="line">    [fromlonlat longitude latitude]：我们指定经纬度来作为中心点</span><br><span class="line">    [byradius radius m|km|ft|mi]：根据给定的radius范围在圆形区域内搜素（参考雷达图）</span><br><span class="line">    [bybox width height m|km|ft|mi]：根据给定的width X坐标 height Y坐标 中轴对齐的矩形内中心点搜素</span><br><span class="line">    [asc|desc]：返回结果按照离中心节点的距离做升序或者降序</span><br><span class="line">    [count count [any]]：指定返回结果的数量</span><br><span class="line">    [withcoord]：返回的结果中包含经纬度</span><br><span class="line">    [withdist]：返回的结果中包含离中心点的位置距离</span><br><span class="line">    [withhash]：返回的结果中包含geohash（此值用来表示经纬度，但是用hash不是太准）</span><br><span class="line">    注：frommember与fromlonlat不能同时出现，只能选择其一</span><br><span class="line">    注：byradius与bybox不能同时出现，只能选择其一</span><br><span class="line">    举例：</span><br><span class="line">        127.0.0.1:6379&gt; geosearch wan frommember hefei  byradius 500 km count 2 withcoord withdist withhash</span><br><span class="line">        1) 1) "hefei"</span><br><span class="line">           2) "0.0000"</span><br><span class="line">           3) (integer) 4052763834193093</span><br><span class="line">           4) 1) "117.30793744325637817"</span><br><span class="line">              2) "31.79321915080526395"</span><br><span class="line">        2) 1) "luan"</span><br><span class="line">           2) "72.8279"</span><br><span class="line">           3) (integer) 4052658908461674</span><br><span class="line">           4) 1) "116.53948992490768433"</span><br><span class="line">              2) "31.74933045393131437"</span><br><span class="line">           -- 按照指定空间元素为中心点，并以圆形区域搜素；但是hefei自身离自己距离是0.0km也输出</span><br><span class="line"></span><br><span class="line">        127.0.0.1:6379&gt; geosearch wan fromlonlat 115.22 29.34 bybox 500 400 km count 2 withcoord withdist withhash</span><br><span class="line">        1) 1) "chizhou"</span><br><span class="line">           2) "271.1848"</span><br><span class="line">           3) (integer) 4052698622569884</span><br><span class="line">           4) 1) "117.56732851266860962"</span><br><span class="line">              2) "30.68672971895555435"</span><br><span class="line">           -- 按照指定经纬度为中心点坐矩形范围查询</span><br><span class="line"></span><br><span class="line">语法：geosearchstore destination source [frommember member] [fromlonlat longitude latitude] [byradius radius m|km|ft|mi] [bybox width height m|km|ft|mi] [asc|desc] [count count [any]] [storedist]</span><br><span class="line">语法：和geosearch相似，只不过geosearchstore命令是将结果返回到指定空间集合里</span><br><span class="line">    destination：新空间集合名称（返回的结果保存到此集合）</span><br><span class="line">    source：空间集合key，和geosearch里的key一样</span><br><span class="line">    storedist：storedist代表写出外部集合（并携带距离中心点距离），默认”store分数“为geohash</span><br><span class="line">    举例：</span><br><span class="line">        127.0.0.1:6379&gt; geosearchstore newWan wan fromlonlat 115.22 29.66 byradius 500 km storedist count 1</span><br><span class="line">        (integer) 1</span><br><span class="line">        127.0.0.1:6379&gt; zrange newWan 0 -1 withscores</span><br><span class="line">        1) "chizhou"</span><br><span class="line">        2) "252.94646681717083"</span><br></pre></td></tr></tbody></table></figure>





<h2 id="十：HyperLogLog（超级基数统计）特殊类型命令"><a href="#十：HyperLogLog（超级基数统计）特殊类型命令" class="headerlink" title="十：HyperLogLog（超级基数统计）特殊类型命令"></a>十：HyperLogLog（超级基数统计）特殊类型命令</h2><p>HyperLogLog主要是用来大数据量统计的类型算法，比如我们统计网站的一天访问量；虽然我们可以使用Redis中String类型的incr、incrby来实现，但是它只能统计访问本网站的每个请求计数累加（除了程序控制），但是我要说每个IP请求多少次都算作一次，对于多个相同IP的请求需要去重计数，在这种环境下HyperLogLog是优选，虽然hash、set、bitmaps可以解决这种问题，但随着数据不断增加，导致占用空间越来越大，对于非常大的数据集是不切实际的；</p>
<p>其实HyperLogLog底层还是一个Redis的String类型，只是用特有算法来实现这个数据类型，它是在降低一定的精确度来平衡和减少空间的存储，**标准误差只有0.81%**；对于统计这些数据精确度不是太大的完全够用了，如果需要统计准确的计数，那还是老老实实使用set这些类型，只能牺牲空间来维持精度；</p>
<p>HyperLogLog用来做基数统计的算法，优点是在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。<strong>每个HyperLogLog键只需要花费12KB内存，就可以计算接近2^64个不同元素的基数</strong>。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。但是<strong>HyperLogLog只会根据输入元素来计算基数，而不会储存输入元素本身</strong>，所以HyperLogLog不能像集合那样，返回输入的各个元素。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">语法：pfadd key [element [element ...]]</span><br><span class="line">说明：添加指定元素到hyperloglog中，如果指定的键不存在，该命令会自动创建一个空的hyperloglog结构</span><br><span class="line">    注：添加的元素已存在的话将不在执行计数统计，都为相同元素的话将返回0，若有添加成功的都会返回1</span><br><span class="line">    pfadd nameA zhangsan lisi wangwu mazi zhangsan xiejun mazi  -- 添加元素</span><br><span class="line">    pfadd nameB xiechao xiaoyang wangwu xiexiao</span><br><span class="line"></span><br><span class="line">语法：pfcount key [key ...]</span><br><span class="line">说明：返回一个或多个键内统计基数（就是返回不相同的元素个数，用来统计），计算统计误差在0.81%</span><br><span class="line">    127.0.0.1:6379&gt; pfcount nameA nameB     -- 统计nameA 和 nameB 里的不重复基数</span><br><span class="line">    (integer) 8</span><br><span class="line"></span><br><span class="line">语法：pfmerge destkey sourcekey [sourcekey ...]</span><br><span class="line">说明：统计一个或多个键内统计基数并放到外部集合里</span><br><span class="line">    127.0.0.1:6379&gt; pfmerge newCount nameA nameB    -- newCount为外部集合，nameA，nameB为要统计的数据</span><br><span class="line">    OK</span><br><span class="line">    127.0.0.1:6379&gt; pfcount newCount</span><br><span class="line">    (integer) 8</span><br></pre></td></tr></tbody></table></figure>





<h2 id="十一：BitMap（位图）特殊类型命令"><a href="#十一：BitMap（位图）特殊类型命令" class="headerlink" title="十一：BitMap（位图）特殊类型命令"></a>十一：BitMap（位图）特殊类型命令</h2><p>BitMap是一串连续的二进制数字（0和1），类似于位数组，每一位所在的位置为偏移量（offset），类似于数组索引，BitMap就是通过最小的单位bit来进行0|1的设置，时间复杂度位O(1)，表示某个元素的值或者状态。由于bit是计算机中最小的单位，使用它进行储存将非常节省空间。特别适合一些数据量大的场景。例如，统计每日活跃用户、统计每月打卡数等统计场景。1天记录1000W用户的活跃统计数据，只需要10000000/8/1024/1024 ≈1.2M。</p>
<p>Redis从2.2.0 ~ 6.2.0这些版本中陆陆续续新增了setbit，getbit，bitcount，bitop等几个BitMap相关命令，虽然是新命令，但是并没有增加新的数据类型，它还是属于String类型。Redis中的BitMap最大占用内存大小限制在512M之内，即2^32。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">基本介绍：</span><br><span class="line">    在计算机中我们常常使用byte（字节）来作为最小单位，每一个byte由8位二进制数组成，即8bit（比特，也称"位"，8位二进制数0和1组成）</span><br><span class="line">    8bit(位) = 1B      [Byte=B]     字节(最小单位)</span><br><span class="line">    1024 B  = 1 KB    [KiloByte]    千字节</span><br><span class="line">    1024 KB = 1 MB    [MegaByte]    兆字节</span><br><span class="line">    1024 MB = 1 GB    [GigaByte]    吉字节</span><br><span class="line">    1024 GB = 1 TB    [TeraByte]    太字节</span><br><span class="line">    1024 TB = 1 PB    [PetaByte]    拍字节</span><br><span class="line">    1024 PB = 1 EB    [ExaByte]     艾字节</span><br><span class="line">    1024 EB = 1 ZB    [ZetaByte]    皆字节</span><br><span class="line">    1024 ZB = 1 YB    [YottaByte]   佑字节</span><br><span class="line">    1024 YB = 1 BB    [Brontobyte]  珀字节</span><br><span class="line">    1024 BB = 1 NB    [NonaByte]    诺字节</span><br><span class="line">    1024 NB = 1 DB    [DoggaByte]   刀字节</span><br><span class="line">BitMap：</span><br><span class="line">    bitMap就是通过最小单位bit来设置值，用来表示不同的两个状态；一个bit只能设置0或者1，所以bit只能存储两个状态</span><br></pre></td></tr></tbody></table></figure>



<p><strong>1：常用命令</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">语法：setbit key offset value</span><br><span class="line">说明：设置或清除存在当前key里指定offset(偏移)位置上的位（可设置0或1，否和是）</span><br><span class="line">    举例：</span><br><span class="line">        setbit  record 0 1     setbit  record 8 1      setbit  record 16 1     setbit  record 24 1</span><br><span class="line">        setbit  record 1 1     setbit  record 9 1      setbit  record 17 1     setbit  record 25 0</span><br><span class="line">        setbit  record 2 1     setbit  record 10 1     setbit  record 18 0     setbit  record 26 0</span><br><span class="line">        setbit  record 3 1     setbit  record 11 0     setbit  record 19 0     setbit  record 27 0</span><br><span class="line">        setbit  record 4 1     setbit  record 12 0     setbit  record 20 1     setbit  record 28 0</span><br><span class="line">        setbit  record 5 1     setbit  record 13 0     setbit  record 21 0     setbit  record 29 0</span><br><span class="line">        setbit  record 6 1     setbit  record 14 0     setbit  record 22 1     setbit  record 30 1</span><br><span class="line">        setbit  record 7 1     setbit  record 15 1     setbit  record 23 1     setbit  record 31 0</span><br><span class="line">    解释：1字节八位，所以我上面是0~7一组、8~15一组、16~23一组、24~31一组，正好可以用来记录一个月的签到情况；</span><br><span class="line">        11111111   11100001   11001011   10000010      ==&gt;存储这几个记录用了 4Byte字节，可以记录一个月</span><br><span class="line">        使用strlen来计算长度   strlen record   等于 4Byte</span><br><span class="line">    注：我们设置值有时不需要一个一个设置，比如</span><br><span class="line">        setbit test 5 1</span><br><span class="line">        setbit test 20 1</span><br><span class="line">        最终存储是这样的 =&gt; 00000100   00000000   00001000    【从左往右看或者获取】</span><br><span class="line"></span><br><span class="line">语法：getbit key offset</span><br><span class="line">说明：返回存储在key的字符串值中offset处的位值，就和我们上面添加的获取一样，获取22位=1、21位=0，0位=1</span><br><span class="line">    getbit record 22</span><br><span class="line">    注：以record的key来说，当获取偏移量超过31的话，那么字符串就会假定为一个连续的空间，那些连续的空间都当作0，</span><br><span class="line">        所有我获取偏移量500的话，那么会从31~500都是0，最后我们返回也是0；若当前key不存在，获取一个随机偏移量，那么</span><br><span class="line">        也会从0位往后都被假定为0，返回也是0</span><br><span class="line"></span><br><span class="line">语法：bitcount key [start end]</span><br><span class="line">说明：计算字符串中设置位数为1的个数，默认情况下获取字符串中所有字节的统计，指定范围则使用start、end；</span><br><span class="line">    [start end]：</span><br><span class="line">        我们以上面设置的为例：=&gt; 11111111   11100001   11001011   10000010</span><br><span class="line">        存储可以看为字符串数组一样正好对应上面 【0 , 1 , 2 , 3】</span><br><span class="line">    注：start和end可以设置负数，负数代表从后往前</span><br><span class="line">    bitcount record 0 0      代表查询【11111111】=8</span><br><span class="line">    bitcount record 0 2      代表查询【11111111 11100001 11001011】=17</span><br><span class="line">    bitcount record 1 2      代表查询【11100001 11001011】=9</span><br><span class="line">    bitcount record 0 -1     代表查询【11111111 11100001 11001011 10000010】=19</span><br><span class="line">    bitcount record 0 -2     代表查询【11111111 11100001 11001011】=17</span><br><span class="line">    bitcount record -3 3     代表查询【11100001 11001011 10000010】=11</span><br><span class="line">    bitcount record -1 -2    代表查询【】=0</span><br><span class="line">    bitcount record -3 -1    代表查询【10000010 11001011 11100001】=11</span><br><span class="line">    bitcount record -3 -3    代表查询【11100001】=4</span><br><span class="line">    bitcount record -3 -4    代表查询【】=0</span><br><span class="line">    注：如果都是负数偏移则是反过来的[正数从左往右，负数从右往左]，以下面为例</span><br><span class="line">        bitcount record -3 -4     -3代表终止，-4代表起始</span><br><span class="line">        以上面字节可看作：-4 -3 -2 -1    ；-3是终止点，而-4在后面</span><br><span class="line"></span><br><span class="line">语法：bitop operation destkey key [key ...]</span><br><span class="line">说明：在多个键中执行位运算，并将结果存储到目标键中</span><br><span class="line">    operation：支持四种按位运算分别是：and、or、xor、not；</span><br><span class="line">        and：多个键中对应的位值都相同时才为1</span><br><span class="line">        or：多个键中对应的位值有1则为1</span><br><span class="line">        xor：多个键中对应的位值有1则为1，都为1则为0</span><br><span class="line">        not：值接收一个键，并取当前键里面位的反转值0变为1，1变为0</span><br><span class="line">    destkey：结果存放的key</span><br><span class="line">    示例：</span><br><span class="line">        setbit bitA 0 1       setbit bitB 0 1</span><br><span class="line">        setbit bitA 1 1       setbit bitB 1 0</span><br><span class="line">        setbit bitA 2 0       setbit bitB 2 1</span><br><span class="line">        setbit bitA 3 1       setbit bitB 3 0</span><br><span class="line">        setbit bitA 4 1       setbit bitB 4 0</span><br><span class="line">        setbit bitA 5 0       setbit bitB 5 0</span><br><span class="line">        setbit bitA 6 0       setbit bitB 6 1</span><br><span class="line">        setbit bitA 7 1       setbit bitB 7 1</span><br><span class="line">        bitop and newBit bitA bitB</span><br><span class="line">            and =&gt; newBit内部存储【10000001】=&gt;2</span><br><span class="line">        bitop or newBit bitA bitB</span><br><span class="line">            or =&gt; newBit内部存储【11111011】=&gt;7</span><br><span class="line">        bitop xor newBit bitA bitB</span><br><span class="line">            xor =&gt; newBit内部存储【01111010】=&gt;5</span><br><span class="line">        bitop not newBit bitA</span><br><span class="line">            not =&gt; newBit内部存储【00100110】=&gt;3</span><br><span class="line"></span><br><span class="line">语法：bitpos key bit [start [end]]</span><br><span class="line">说明：返回位图中第一次出现1或者0的位置，默认是从位图0位置开始查找，也可指定start、end</span><br><span class="line">    key：要查询的位图</span><br><span class="line">    bit：值只可写0或者1，告知在位图中查询第一次出现的位置</span><br><span class="line">    [start [end]]：范围，可以单写start，或者start和end一起</span><br><span class="line">    举例：record：=&gt; 11111111   11100001   11001011   10000010</span><br><span class="line">        bitpos record 1</span><br><span class="line">            返回0；代表所有字节查询，查询第一次出现位值为1的位置</span><br><span class="line">        bitpos record 0</span><br><span class="line">            返回11；代表所有字节查询，查询第一次出现位值为0的位置（0开始索引）</span><br><span class="line">        bitpos record 0 2 3</span><br><span class="line">            返回18；代表范围查询，查询第一次出现位值为0的位置（0开始索引）</span><br><span class="line">    注：默认情况下，检查位图包含的所有字节，若指定范围则可以使用start和end来定位，start和end的范围</span><br><span class="line">        查询是以字节来说明的，比如start=1，end=2，则查询范围为【11100001 11001011】；还有就是，即使设置</span><br><span class="line">        start和end来指定范围，位位置也始终从0开始；算上start之前的字节＋start~end之间查询到第一次出现的位置</span><br></pre></td></tr></tbody></table></figure></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://github.com/hejixing">Star</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://github.com/2021/12/10/redis%E5%91%BD%E4%BB%A4/">https://github.com/2021/12/10/redis%E5%91%BD%E4%BB%A4/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://github.com" target="_blank">Star</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/redis/">redis</a></div><div class="post_share"><div class="social-share" data-image="https://pic.imgdb.cn/item/657bab7ec458853aef5b7772.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer=""></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/12/15/JRedis/" title="JRedis"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/657bab7ec458853aef5b7772.jpg" onerror="onerror=null;src='https://pic.imgdb.cn/item/656970e1c458853aef2dc978.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">JRedis</div></div></a></div><div class="next-post pull-right"><a href="/2021/12/04/redis/" title="redis"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/657bab7ec458853aef5b7772.jpg" onerror="onerror=null;src='https://pic.imgdb.cn/item/656970e1c458853aef2dc978.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">redis</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2021/12/15/JRedis/" title="JRedis"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/657bab7ec458853aef5b7772.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-15</div><div class="title">JRedis</div></div></a></div><div><a href="/2021/12/02/Linux%E4%B8%8BRedis%E7%9A%84%E5%AE%89%E8%A3%85/" title="Linux下Redis的安装"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/657bab7ec458853aef5b7772.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-02</div><div class="title">Linux下Redis的安装</div></div></a></div><div><a href="/2021/12/04/redis/" title="redis"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/657bab7ec458853aef5b7772.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-04</div><div class="title">redis</div></div></a></div><div><a href="/2021/12/03/%E5%AE%89%E8%A3%85redis%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B7%A5%E5%85%B7AnotherRedisDesktopManager/" title="安装redis可视化工具AnotherRedisDesktopManager"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/657bab7ec458853aef5b7772.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-03</div><div class="title">安装redis可视化工具AnotherRedisDesktopManager</div></div></a></div></div></div><hr class="custom-hr"><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/6569700cc458853aef2b204a.png" onerror="this.onerror=null;this.src='https://pic.imgdb.cn/item/65697120c458853aef2e8481.gif'" alt="avatar"></div><div class="author-info__name">Star</div><div class="author-info__description">慢慢变成自己想要的样子</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">53</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">21</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">21</div></a></div><a id="card-info-btn" href="https://github.com/hejixing"><i class="fab fa-github"></i><span>关注我</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/hejixing" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:1812627638@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #24292e;"></i></a><a class="social-icon" href="https://pic.imgdb.cn/item/656adba2c458853aef9f0dba.jpg" target="_blank" title="QQ"><i class="fab fa-qq" style="color: #24292e;"></i></a><a class="social-icon" href="https://pic.imgdb.cn/item/656adca2c458853aefa3e59a.jpg" target="_blank" title="Wechat"><i class="fab fa-weixin" style="color: #24292e;"></i></a><a class="social-icon" href="https://space.bilibili.com/1068653440?spm_id_from=333.999.0.0" target="_blank" title="B站"><i class="fab fa-bilibili" style="color: #24292e;"></i></a><a class="social-icon" href="https://www.weibo.com/u/6625868193" target="_blank" title="Weibo"><i class="fab fa-weibo" style="color: #24292e;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content"><div> <p style="color:#ea66a6;text-align:center;font-size:16px">欢迎来到小何の博客</p> <p style="text-align:center"> <a style="color:#8552a1;font-size:16px" target="_blank" rel="noopener" href="http://www.hejixing.cn/">--- 主站 ---</a></p> <p style="text-align:center"><a style="color:#8552a1;font-size:16px" target="_blank" rel="noopener" href="http://www.hejixing.cn/">www.hejixing.cn</a></p> <p style="text-align:center"><a style="color:#00ae9d;font-size:16px" target="_blank" rel="noopener" href="https://hejixing.github.io/">--- 备用网站 ---</a></p> <p style="text-align:center"><a style="color:#00ae9d;font-size:16px" target="_blank" rel="noopener" href="https://hejixing.github.io/">hejixing.github.io</a></p> </div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis%E5%91%BD%E4%BB%A4"><span class="toc-number">1.</span> <span class="toc-text">Redis命令</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8%EF%BC%88%E8%B6%85%E8%AF%A6%E7%BB%86%EF%BC%89"><span class="toc-number">2.</span> <span class="toc-text">Redis命令大全（超详细）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%EF%BC%9A%E5%BA%8F"><span class="toc-number">2.1.</span> <span class="toc-text">一：序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%EF%BC%9ARedis%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E5%8F%8A%E5%B8%B8%E8%AF%86"><span class="toc-number">2.2.</span> <span class="toc-text">二：Redis基本命令及常识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%EF%BC%9AString%EF%BC%88%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%89%E7%B1%BB%E5%9E%8B%E5%91%BD%E4%BB%A4"><span class="toc-number">2.3.</span> <span class="toc-text">四：String（字符串）类型命令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%EF%BC%9AHash%EF%BC%88%E5%93%88%E5%B8%8C%E8%A1%A8%EF%BC%89%E7%B1%BB%E5%9E%8B%E5%91%BD%E4%BB%A4"><span class="toc-number">2.4.</span> <span class="toc-text">五：Hash（哈希表）类型命令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%EF%BC%9AList%EF%BC%88%E9%9B%86%E5%90%88%EF%BC%89%E7%B1%BB%E5%9E%8B%E5%91%BD%E4%BB%A4"><span class="toc-number">2.5.</span> <span class="toc-text">六：List（集合）类型命令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%EF%BC%9ASet%EF%BC%88%E6%97%A0%E5%BA%8F%E9%9B%86%E5%90%88%EF%BC%89%E7%B1%BB%E5%9E%8B%E5%91%BD%E4%BB%A4"><span class="toc-number">2.6.</span> <span class="toc-text">七：Set（无序集合）类型命令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%EF%BC%9ASortedSet%EF%BC%88%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88%EF%BC%89%E7%B1%BB%E5%9E%8B%E5%91%BD%E4%BB%A4"><span class="toc-number">2.7.</span> <span class="toc-text">八：SortedSet（有序集合）类型命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%9A%E6%B7%BB%E5%8A%A0%E5%91%BD%E4%BB%A4"><span class="toc-number">2.7.1.</span> <span class="toc-text">1：添加命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%9A%E6%9F%A5%E8%AF%A2%E5%91%BD%E4%BB%A4"><span class="toc-number">2.7.2.</span> <span class="toc-text">2：查询命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%EF%BC%9A%E5%88%A0%E9%99%A4%E5%91%BD%E4%BB%A4"><span class="toc-number">2.7.3.</span> <span class="toc-text">3：删除命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%EF%BC%9A%E5%85%B6%E5%AE%83%E5%91%BD%E4%BB%A4"><span class="toc-number">2.7.4.</span> <span class="toc-text">4：其它命令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%9D%EF%BC%9AGeoSpatial%EF%BC%88%E5%9C%B0%E7%90%86%E7%A9%BA%E9%97%B4%EF%BC%89%E7%89%B9%E6%AE%8A%E7%B1%BB%E5%9E%8B%E5%91%BD%E4%BB%A4"><span class="toc-number">2.8.</span> <span class="toc-text">九：GeoSpatial（地理空间）特殊类型命令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%EF%BC%9AHyperLogLog%EF%BC%88%E8%B6%85%E7%BA%A7%E5%9F%BA%E6%95%B0%E7%BB%9F%E8%AE%A1%EF%BC%89%E7%89%B9%E6%AE%8A%E7%B1%BB%E5%9E%8B%E5%91%BD%E4%BB%A4"><span class="toc-number">2.9.</span> <span class="toc-text">十：HyperLogLog（超级基数统计）特殊类型命令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%B8%80%EF%BC%9ABitMap%EF%BC%88%E4%BD%8D%E5%9B%BE%EF%BC%89%E7%89%B9%E6%AE%8A%E7%B1%BB%E5%9E%8B%E5%91%BD%E4%BB%A4"><span class="toc-number">2.10.</span> <span class="toc-text">十一：BitMap（位图）特殊类型命令</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/12/15/%E5%AF%B9%E6%8E%A5Amazon%E5%B9%B3%E5%8F%B0API-md/" title="对接Amazon平台API.md"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/65ed7bbc9f345e8d036f71d9.jpg" onerror="this.onerror=null;this.src='https://pic.imgdb.cn/item/656970e1c458853aef2dc978.jpg'" alt="对接Amazon平台API.md"></a><div class="content"><a class="title" href="/2023/12/15/%E5%AF%B9%E6%8E%A5Amazon%E5%B9%B3%E5%8F%B0API-md/" title="对接Amazon平台API.md">对接Amazon平台API.md</a><time datetime="2023-12-15T12:31:03.000Z" title="发表于 2023-12-15 20:31:03">2023-12-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/12/10/%E5%AF%B9%E6%8E%A5Wayfair%E5%B9%B3%E5%8F%B0API-md/" title="对接Wayfair平台API.md"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/65ed7b439f345e8d036c89d2.jpg" onerror="this.onerror=null;this.src='https://pic.imgdb.cn/item/656970e1c458853aef2dc978.jpg'" alt="对接Wayfair平台API.md"></a><div class="content"><a class="title" href="/2023/12/10/%E5%AF%B9%E6%8E%A5Wayfair%E5%B9%B3%E5%8F%B0API-md/" title="对接Wayfair平台API.md">对接Wayfair平台API.md</a><time datetime="2023-12-10T12:31:03.000Z" title="发表于 2023-12-10 20:31:03">2023-12-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/12/05/%E5%AF%B9%E6%8E%A5Walmart%E5%B9%B3%E5%8F%B0API/" title="对接Walmart平台API"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/657baaecc458853aef5a3c64.jpg" onerror="this.onerror=null;this.src='https://pic.imgdb.cn/item/656970e1c458853aef2dc978.jpg'" alt="对接Walmart平台API"></a><div class="content"><a class="title" href="/2023/12/05/%E5%AF%B9%E6%8E%A5Walmart%E5%B9%B3%E5%8F%B0API/" title="对接Walmart平台API">对接Walmart平台API</a><time datetime="2023-12-05T12:31:03.000Z" title="发表于 2023-12-05 20:31:03">2023-12-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/10/10/%E5%AF%B9%E6%8E%A5%E9%B9%B0%E4%BB%93%E4%BD%BF%E7%94%A8%E7%9A%84Web-Services-api-md/" title="对接鹰仓使用的Web Services  api.md"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/65ed820f9f345e8d039130e1.jpg" onerror="this.onerror=null;this.src='https://pic.imgdb.cn/item/656970e1c458853aef2dc978.jpg'" alt="对接鹰仓使用的Web Services  api.md"></a><div class="content"><a class="title" href="/2023/10/10/%E5%AF%B9%E6%8E%A5%E9%B9%B0%E4%BB%93%E4%BD%BF%E7%94%A8%E7%9A%84Web-Services-api-md/" title="对接鹰仓使用的Web Services  api.md">对接鹰仓使用的Web Services  api.md</a><time datetime="2023-10-10T12:31:03.000Z" title="发表于 2023-10-10 20:31:03">2023-10-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/09/09/RabbitMq-md/" title="RabbitMq.md"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/65ed83ef9f345e8d039b9b61.jpg" onerror="this.onerror=null;this.src='https://pic.imgdb.cn/item/656970e1c458853aef2dc978.jpg'" alt="RabbitMq.md"></a><div class="content"><a class="title" href="/2023/09/09/RabbitMq-md/" title="RabbitMq.md">RabbitMq.md</a><time datetime="2023-09-09T12:56:22.000Z" title="发表于 2023-09-09 20:56:22">2023-09-09</time></div></div></div></div></div></div></main><footer id="footer" style="background: transparent"><div id="footer-wrap"><div class="copyright">©2020 - 2024 By Star</div><div class="framework-info"><!--span= '小小博客，多多关照'--></div><div class="framework-info"><!--span= _p('footer.framework') + ' '--><!--a(href='https://hexo.io')= 'Hexo'--><!--span.footer-separator |--><!--span= _p('footer.theme') + ' '--><!--a(href='https://github.com/jerryc127/hexo-theme-butterfly')= 'Butterfly'--></div><div class="footer_custom_text"><a href="https://beian.miit.gov.cn/#/Integrated/index" style="color:white" target="_blank">闽ICP备2023026479号</a> <br> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/备案图标.png" class="icp-icon"><a href="https://beian.mps.gov.cn/#/query/webSearch?code=35021102002047" rel="noreferrer" target="_blank">闽公网安备35021102002047</a> <br> <span>小小博客，多多关照</span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const initValine = () => {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'e4NbZwwcEORNv0U6fBvBIQIk-gzGzoHsz',
      appKey: 'MedM3CXI51sGzg9FKVRSurCD',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  const loadValine = async () => {
    if (typeof Valine === 'function') initValine()
    else {
      await getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js')
      initValine()
    }
  }

  if ('Valine' === 'Valine' || !false) {
    if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
    else setTimeout(loadValine, 0)
  } else {
    window.loadOtherComment = loadValine
  }
})()</script></div><script src="https://cdn.jsdelivr.net/npm/blueimp-md5/js/md5.min.js"></script><script>window.addEventListener('load', () => {
  const changeContent = (content) => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const getIcon = (icon, mail) => {
    if (icon) return icon
    let defaultIcon = '?d=monsterid'
    let iconUrl = `https://gravatar.loli.net/avatar/${md5(mail.toLowerCase()) + defaultIcon}`
    return iconUrl
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'data-lazy-src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'></a>`
        }

        result += `<div class='content'>
        <a class='comment' href='${array[i].url}' title='${array[i].content}'>${array[i].content}</a>
        <div class='name'><span>${array[i].nick} / </span><time datetime="${array[i].date}">${btf.diffDate(array[i].date, true)}</time></div>
        </div></div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom.innerHTML= result
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const getComment = () => {
    const serverURL = 'https://e4NbZwwc.api.lncldglobal.com'

    var settings = {
      "method": "GET",
      "headers": {
        "X-LC-Id": 'e4NbZwwcEORNv0U6fBvBIQIk-gzGzoHsz',
        "X-LC-Key": 'MedM3CXI51sGzg9FKVRSurCD',
        "Content-Type": "application/json"
      },
    }

    fetch(`${serverURL}/1.1/classes/Comment?limit=6&order=-createdAt`,settings)
      .then(response => response.json())
      .then(data => {
        const valineArray = data.results.map(function (e) {
          return {
            'avatar': getIcon(e.QQAvatar, e.mail),
            'content': changeContent(e.comment),
            'nick': e.nick,
            'url': e.url + '#' + e.objectId,
            'date': e.updatedAt,
          }
        })
        saveToLocal.set('valine-newest-comments', JSON.stringify(valineArray), 10/(60*24))
        generateHtml(valineArray)
      }).catch(e => {
        const $dom = document.querySelector('#card-newest-comments .aside-list')
        $dom.textContent= "无法获取评论，请确认相关配置是否正确"
      }) 
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('valine-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><script src="/js/snowflake.js"></script><link rel="stylesheet" href="/css/mouse/mouse.css"><script src="https://widget.qweather.net/simple/static/js/he-simple-common.js?v=2.0"></script><script src="/js/weather.js"></script><div class="aplayer no-destroy" data-id="3039291125" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="true"> </div><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener
  btf.removeGlobalFnEvent('pjax')
  btf.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async="" data-pjax="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/haruto.model.json"},"display":{"position":"right","width":180,"height":360},"mobile":{"show":true},"react":{"opacity":0.9}});</script></body></html>